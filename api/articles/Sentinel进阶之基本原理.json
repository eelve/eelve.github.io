{"title":"Sentinel进阶之基本原理","slug":"Sentinel进阶之基本原理","date":"2021-05-30T05:01:11.000Z","updated":"2023-09-30T08:39:39.682Z","comments":true,"path":"api/articles/Sentinel进阶之基本原理.json","excerpt":null,"covers":["https://image.eelve.com/eblog/2021053001.png","https://image.eelve.com/eblog/2021053002.png","https://image.eelve.com/eblog/2021053003.png","https://image.eelve.com/eblog/2021053001.png","https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png"],"content":"<p>【<strong>前面的话</strong>】在前文 <a href=\"https://eelve.com/posts/d2ca763d.html\">Sentinel入门指北</a> 中简单介绍了一下<code>Sentinel</code>，今天就来具体说一下<code>Sentinel</code>的基本原理。</p>\n<hr>\n<h1 id=\"壹、概述\"><a href=\"#壹、概述\" class=\"headerlink\" title=\"壹、概述\"></a>壹、概述</h1><p>在 <code>Sentinel</code> 里面，所有的资源都对应一个资源名称以及一个 <code>Entry</code>。<code>Entry</code> 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 <code>API</code> 显式创建；每一个 <code>Entry</code> 创建的时候，同时也会创建一系列功能插槽（slot chain）。这些插槽有不同的职责，例如:</p>\n<ul>\n<li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级； </li>\n<li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如该资源的 <code>RT</code>, <code>QPS</code>, <code>thread count</code> 等等，这些信息将用作为多维度限流，降级的依据；</li>\n<li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 <code>runtime</code> 指标监控信息；</li>\n<li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 <code>slot</code> 统计的状态，来进行流量控制；</li>\n<li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li>\n<li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li>\n<li><code>SystemSlot</code> 则通过系统的状态，例如 <code>load1</code> 等，来控制总的入口流量；</li>\n</ul>\n<p>总体的框架如下:</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053001.png\" alt=\"总体框架图\"></p>\n<p><code>Sentinel</code> 将 <code>ProcessorSlot</code> 作为 <code>SPI</code> 接口进行扩展（1.7.2 版本以前 <code>SlotChainBuilder</code> 作为 <code>SPI</code>），使得 <code>Slot Chain</code> 具备了扩展的能力。您可以自行加入自定义的 <code>slot</code> 并编排 <code>slot</code> 间的顺序，从而可以给 <code>Sentinel</code> 添加自定义的功能。</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053002.png\" alt=\"自定义处理流程\"></p>\n<p>下面介绍一下各个 <code>slot</code> 的功能。</p>\n<h2 id=\"1-1、NodeSelectorSlot\"><a href=\"#1-1、NodeSelectorSlot\" class=\"headerlink\" title=\"1.1、NodeSelectorSlot\"></a>1.1、NodeSelectorSlot</h2><p>这个 <code>slot</code> 主要负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContextUtil.enter(<span class=\"string\">&quot;entrance1&quot;</span>, <span class=\"string\">&quot;appA&quot;</span>);</span><br><span class=\"line\">Entry nodeA = SphU.entry(<span class=\"string\">&quot;nodeA&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nodeA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   nodeA.exit();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ContextUtil.exit();</span><br></pre></td></tr></table></figure>\n<p>上述代码通过 <code>ContextUtil.enter()</code> 创建了一个名为 <code>entrance1</code> 的上下文，同时指定调用发起者为 <code>appA</code>；接着通过 <code>SphU.entry()</code>请求一个 <code>token</code>，如果该方法顺利执行没有抛 <code>BlockException</code>，表明 <code>token</code> 请求成功。</p>\n<p>以上代码将在内存中生成以下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> machine-root</span><br><span class=\"line\">           &#x2F;     </span><br><span class=\"line\">          &#x2F;</span><br><span class=\"line\">   EntranceNode1</span><br><span class=\"line\">        &#x2F;</span><br><span class=\"line\">       &#x2F;   </span><br><span class=\"line\">DefaultNode(nodeA)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：每个 <code>DefaultNode</code> 由资源 <code>ID</code> 和输入名称来标识。换句话说，一个资源 <code>ID</code> 可以有多个不同入口的 <code>DefaultNode</code>。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContextUtil.enter(<span class=\"string\">&quot;entrance1&quot;</span>, <span class=\"string\">&quot;appA&quot;</span>);</span><br><span class=\"line\">Entry nodeA = SphU.entry(<span class=\"string\">&quot;nodeA&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nodeA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  nodeA.exit();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ContextUtil.exit();</span><br><span class=\"line\"></span><br><span class=\"line\">ContextUtil.enter(<span class=\"string\">&quot;entrance2&quot;</span>, <span class=\"string\">&quot;appA&quot;</span>);</span><br><span class=\"line\">nodeA = SphU.entry(<span class=\"string\">&quot;nodeA&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nodeA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  nodeA.exit();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ContextUtil.exit();</span><br></pre></td></tr></table></figure>\n<p>以上代码将在内存中生成以下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">            machine-root</span><br><span class=\"line\">            &#x2F;         \\</span><br><span class=\"line\">           &#x2F;           \\</span><br><span class=\"line\">   EntranceNode1   EntranceNode2</span><br><span class=\"line\">         &#x2F;               \\</span><br><span class=\"line\">        &#x2F;                 \\</span><br><span class=\"line\">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure>\n<p>上面的结构可以通过调用 <code>curl http://localhost:8719/tree?type=root</code> 来显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EntranceNode: machine-root(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">-EntranceNode1: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">-EntranceNode2: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\"></span><br><span class=\"line\">t:threadNum  pq:passQps  bq:blockedQps  tq:totalQps  rt:averageRt  prq: passRequestQps 1mp:1m-passed 1mb:1m-blocked 1mt:1m-total</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2、ClusterBuilderSlot\"><a href=\"#1-2、ClusterBuilderSlot\" class=\"headerlink\" title=\"1.2、ClusterBuilderSlot\"></a>1.2、ClusterBuilderSlot</h2><p>此插槽用于构建资源的 <code>ClusterNode</code> 以及调用来源节点。<code>ClusterNode</code> 保持资源运行统计信息（响应时间、QPS、block 数目、线程数、异常数等）以及原始调用者统计信息列表。来源调用者的名字由 <code>ContextUtil.enter(contextName，origin)</code> 中的 <code>origin</code> 标记。可通过如下命令查看某个资源不同调用者的访问情况：<code>curl http://localhost:8719/origin?id=caller</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id: nodeA</span><br><span class=\"line\">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class=\"line\">1   caller1 0         0         0          0        0     0         0          0        </span><br><span class=\"line\">2   caller2 0         0         0          0        0     0         0          0      </span><br></pre></td></tr></table></figure>\n<h2 id=\"1-3、StatisticSlot\"><a href=\"#1-3、StatisticSlot\" class=\"headerlink\" title=\"1.3、StatisticSlot\"></a>1.3、StatisticSlot</h2><p><code>StatisticSlot</code> 是 <code>Sentinel</code> 的核心功能插槽之一，用于统计实时的调用数据。</p>\n<ul>\n<li><code>clusterNode</code>：资源唯一标识的 <code>ClusterNode</code> 的 <code>runtime</code> 统计 </li>\n<li><code>origin</code>：根据来自不同调用者的统计信息</li>\n<li><code>defaultnode</code>: 根据上下文条目名称和资源 <code>ID</code> 的 <code>runtime</code> 统计</li>\n<li>入口的统计</li>\n</ul>\n<p><code>Sentinel</code> 底层采用高性能的滑动窗口数据结构 <code>LeapArray</code> 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053003.png\" alt=\"滑动窗口\"></p>\n<h2 id=\"1-4、FlowSlot\"><a href=\"#1-4、FlowSlot\" class=\"headerlink\" title=\"1.4、FlowSlot\"></a>1.4、FlowSlot</h2><p>这个 <code>slot</code> 主要根据预设的资源的统计信息，按照固定的次序，依次生效。如果一个资源对应两条或者多条流控规则，则会根据如下次序依次检验，直到全部通过或者有一个规则生效为止:</p>\n<ul>\n<li>指定应用生效的规则，即针对调用方限流的；</li>\n<li>调用方为 other 的规则；</li>\n<li>调用方为 default 的规则。</li>\n</ul>\n<h2 id=\"1-5、DegradeSlot\"><a href=\"#1-5、DegradeSlot\" class=\"headerlink\" title=\"1.5、DegradeSlot\"></a>1.5、DegradeSlot</h2><p>这个 <code>slot</code> 主要针对资源的平均响应时间（RT）以及异常比率，来决定资源是否在接下来的时间被自动熔断掉。</p>\n<h2 id=\"1-6、SystemSlot\"><a href=\"#1-6、SystemSlot\" class=\"headerlink\" title=\"1.6、SystemSlot\"></a>1.6、SystemSlot</h2><p>这个 <code>slot</code> 会根据对于当前系统的整体情况，对入口资源的调用进行动态调配。其原理是让入口的流量和当前系统的预计容量达到一个动态平衡。</p>\n<p>注意系统规则只对入口流量起作用（调用类型为 <code>EntryType.IN</code>），对出口流量无效。可通过 <code>SphU.entry(res, entryType)</code> 指定调用类型，如果不指定，默认是<code>EntryType.OUT</code>。</p>\n<h1 id=\"贰、-核心类解析\"><a href=\"#贰、-核心类解析\" class=\"headerlink\" title=\"贰、 核心类解析\"></a>贰、 核心类解析</h1><h2 id=\"2-1、ProcessorSlotChain\"><a href=\"#2-1、ProcessorSlotChain\" class=\"headerlink\" title=\"2.1、ProcessorSlotChain\"></a>2.1、ProcessorSlotChain</h2><p><code>Sentinel</code> 的核心骨架，将不同的 <code>Slot</code> 按照顺序串在一起（责任链模式），从而将不同的功能（限流、降级、系统保护）组合在一起。<code>slot chain</code> 其实可以分为两部分：统计数据构建部分（statistic）和判断部分（rule checking）。核心结构：</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053001.png\" alt=\"总体框架图\"></p>\n<p>目前的设计是 <code>one slot chain per resource</code>，因为某些 <code>slot</code> 是 <code>per resource</code> 的（比如 <code>NodeSelectorSlot</code>）。</p>\n<h2 id=\"2-2、Context\"><a href=\"#2-2、Context\" class=\"headerlink\" title=\"2.2、Context\"></a>2.2、Context</h2><p><code>Context</code> 代表调用链路上下文，贯穿一次调用链路中的所有 <code>Entry</code>。<code>Context</code> 维持着入口节点（entranceNode）、本次调用链路的 <code>curNode</code>、调用来源（origin）等信息。<code>Context</code> 名称即为调用链路入口名称。</p>\n<p><code>Context</code> 维持的方式：通过 <code>ThreadLocal</code> 传递，只有在入口 <code>enter</code> 的时候生效。由于 <code>Context</code> 是通过 <code>ThreadLocal</code> 传递的，因此对于异步调用链路，线程切换的时候会丢掉 <code>Context</code>，因此需要手动通过 <code>ContextUtil.runOnContext(context, f)</code> 来变换 <code>context</code>。</p>\n<h2 id=\"2-3、Entry\"><a href=\"#2-3、Entry\" class=\"headerlink\" title=\"2.3、Entry\"></a>2.3、Entry</h2><p>每一次资源调用都会创建一个 <code>Entry</code>。<code>Entry</code> 包含了资源名、curNode（当前统计节点）、originNode（来源统计节点）等信息。</p>\n<p><code>CtEntry</code> 为普通的 <code>Entry</code>，在调用 <code>SphU.entry(xxx)</code> 的时候创建。特性：<code>Linked entry within current context（内部维护着 parent 和 child）</code></p>\n<p>需要注意的一点：<code>CtEntry</code> 构造函数中会做调用链的变换，即将当前 <code>Entry</code> 接到传入 <code>Context</code> 的调用链路上（setUpEntryFor）。</p>\n<p>资源调用结束时需要 <code>entry.exit()</code>。<code>exit</code> 操作会过一遍 <code>slot chain exit</code>，恢复调用栈，<code>exit context</code> 然后清空 <code>entry</code> 中的 <code>context</code> 防止重复调用。</p>\n<h2 id=\"2-4、Node\"><a href=\"#2-4、Node\" class=\"headerlink\" title=\"2.4、Node\"></a>2.4、Node</h2><p><code>Sentinel</code> 里面的各种种类的统计节点：</p>\n<ul>\n<li><code>StatisticNode</code>：最为基础的统计节点，包含秒级和分钟级两个滑动窗口结构。</li>\n<li><code>DefaultNode</code>：链路节点，用于统计调用链路上某个资源的数据，维持树状结构。</li>\n<li><code>ClusterNode</code>：簇点，用于统计每个资源全局的数据（不区分调用链路），以及存放该资源的按来源区分的调用数据（类型为 <code>StatisticNode</code>）。特别地，<code>Constants.ENTRY_NODE</code> 节点用于统计全局的入口资源数据。</li>\n<li><code>EntranceNode</code>：入口节点，特殊的链路节点，对应某个 <code>Context</code> 入口的所有调用数据。<code>Constants.ROOT</code> 节点也是入口节点。</li>\n</ul>\n<p>构建的时机：</p>\n<ul>\n<li><code>EntranceNode</code>：在 <code>ContextUtil.enter(xxx)</code> 的时候就创建了，然后塞到 <code>Context</code> 里面。</li>\n<li><code>NodeSelectorSlot</code>：根据 <code>context</code> 创建 <code>DefaultNode</code>，然后 <code>set curNode to context</code>。</li>\n<li><code>ClusterBuilderSlot</code>：首先根据 <code>resourceName</code> 创建 <code>ClusterNode</code>，并且 <code>set clusterNode to defaultNode</code>；然后再根据 <code>origin</code> 创建来源节点（类型为 <code>StatisticNode</code>），并且 <code>set originNode to curEntry</code>。</li>\n</ul>\n<p>几种 <code>Node</code> 的维度（数目）：</p>\n<ul>\n<li><code>ClusterNode</code> 的维度是 <code>resource</code></li>\n<li><code>DefaultNode</code> 的维度是 <code>resource * context</code>，存在每个 <code>NodeSelectorSlot</code> 的 <code>map</code> 里面</li>\n<li><code>EntranceNode</code> 的维度是 <code>context</code>，存在 <code>ContextUtil</code> 类的 <code>contextNameNodeMap</code> 里面</li>\n<li>来源节点（类型为 <code>StatisticNode</code>）的维度是 <code>resource * origin</code>，存在每个 <code>ClusterNode</code> 的 <code>originCountMap</code> 里面</li>\n</ul>\n<h2 id=\"2-5、StatisticSlot\"><a href=\"#2-5、StatisticSlot\" class=\"headerlink\" title=\"2.5、StatisticSlot\"></a>2.5、StatisticSlot</h2><p><code>StatisticSlot</code> 是 <code>Sentinel</code> 最为重要的类之一，用于根据规则判断结果进行相应的统计操作。</p>\n<p><code>entry</code> 的时候：依次执行后面的判断 <code>slot</code>。每个 <code>slot</code> 触发流控的话会抛出异常（<code>BlockException</code> 的子类）。若有 BlockException 抛出，则记录 block 数据；若无异常抛出则算作可通过（pass），记录 pass 数据。</p>\n<p><code>exit</code> 的时候：若无 <code>error（无论是业务异常还是流控异常）</code>，记录 <code>complete（success）</code>以及 <code>RT</code>，线程数<code>-1</code>。</p>\n<p>记录数据的维度：线程数<code>+1</code>、记录当前 <code>DefaultNode</code> 数据、记录对应的 <code>originNode</code> 数据（若存在 <code>origin</code>）、累计 <code>IN</code> 统计数据（若流量类型为 <code>IN</code>）。</p>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践自定义调用链的源码</a> 。</p>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","more":"<p>【<strong>前面的话</strong>】在前文 <a href=\"https://eelve.com/posts/d2ca763d.html\">Sentinel入门指北</a> 中简单介绍了一下<code>Sentinel</code>，今天就来具体说一下<code>Sentinel</code>的基本原理。</p>\n<hr>\n<h1 id=\"壹、概述\"><a href=\"#壹、概述\" class=\"headerlink\" title=\"壹、概述\"></a>壹、概述</h1><p>在 <code>Sentinel</code> 里面，所有的资源都对应一个资源名称以及一个 <code>Entry</code>。<code>Entry</code> 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 <code>API</code> 显式创建；每一个 <code>Entry</code> 创建的时候，同时也会创建一系列功能插槽（slot chain）。这些插槽有不同的职责，例如:</p>\n<ul>\n<li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级； </li>\n<li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如该资源的 <code>RT</code>, <code>QPS</code>, <code>thread count</code> 等等，这些信息将用作为多维度限流，降级的依据；</li>\n<li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 <code>runtime</code> 指标监控信息；</li>\n<li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 <code>slot</code> 统计的状态，来进行流量控制；</li>\n<li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li>\n<li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li>\n<li><code>SystemSlot</code> 则通过系统的状态，例如 <code>load1</code> 等，来控制总的入口流量；</li>\n</ul>\n<p>总体的框架如下:</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053001.png\" alt=\"总体框架图\"></p>\n<p><code>Sentinel</code> 将 <code>ProcessorSlot</code> 作为 <code>SPI</code> 接口进行扩展（1.7.2 版本以前 <code>SlotChainBuilder</code> 作为 <code>SPI</code>），使得 <code>Slot Chain</code> 具备了扩展的能力。您可以自行加入自定义的 <code>slot</code> 并编排 <code>slot</code> 间的顺序，从而可以给 <code>Sentinel</code> 添加自定义的功能。</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053002.png\" alt=\"自定义处理流程\"></p>\n<p>下面介绍一下各个 <code>slot</code> 的功能。</p>\n<h2 id=\"1-1、NodeSelectorSlot\"><a href=\"#1-1、NodeSelectorSlot\" class=\"headerlink\" title=\"1.1、NodeSelectorSlot\"></a>1.1、NodeSelectorSlot</h2><p>这个 <code>slot</code> 主要负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContextUtil.enter(<span class=\"string\">&quot;entrance1&quot;</span>, <span class=\"string\">&quot;appA&quot;</span>);</span><br><span class=\"line\">Entry nodeA = SphU.entry(<span class=\"string\">&quot;nodeA&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nodeA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   nodeA.exit();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ContextUtil.exit();</span><br></pre></td></tr></table></figure>\n<p>上述代码通过 <code>ContextUtil.enter()</code> 创建了一个名为 <code>entrance1</code> 的上下文，同时指定调用发起者为 <code>appA</code>；接着通过 <code>SphU.entry()</code>请求一个 <code>token</code>，如果该方法顺利执行没有抛 <code>BlockException</code>，表明 <code>token</code> 请求成功。</p>\n<p>以上代码将在内存中生成以下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> machine-root</span><br><span class=\"line\">           &#x2F;     </span><br><span class=\"line\">          &#x2F;</span><br><span class=\"line\">   EntranceNode1</span><br><span class=\"line\">        &#x2F;</span><br><span class=\"line\">       &#x2F;   </span><br><span class=\"line\">DefaultNode(nodeA)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：每个 <code>DefaultNode</code> 由资源 <code>ID</code> 和输入名称来标识。换句话说，一个资源 <code>ID</code> 可以有多个不同入口的 <code>DefaultNode</code>。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContextUtil.enter(<span class=\"string\">&quot;entrance1&quot;</span>, <span class=\"string\">&quot;appA&quot;</span>);</span><br><span class=\"line\">Entry nodeA = SphU.entry(<span class=\"string\">&quot;nodeA&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nodeA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  nodeA.exit();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ContextUtil.exit();</span><br><span class=\"line\"></span><br><span class=\"line\">ContextUtil.enter(<span class=\"string\">&quot;entrance2&quot;</span>, <span class=\"string\">&quot;appA&quot;</span>);</span><br><span class=\"line\">nodeA = SphU.entry(<span class=\"string\">&quot;nodeA&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nodeA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  nodeA.exit();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ContextUtil.exit();</span><br></pre></td></tr></table></figure>\n<p>以上代码将在内存中生成以下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">            machine-root</span><br><span class=\"line\">            &#x2F;         \\</span><br><span class=\"line\">           &#x2F;           \\</span><br><span class=\"line\">   EntranceNode1   EntranceNode2</span><br><span class=\"line\">         &#x2F;               \\</span><br><span class=\"line\">        &#x2F;                 \\</span><br><span class=\"line\">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure>\n<p>上面的结构可以通过调用 <code>curl http://localhost:8719/tree?type=root</code> 来显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EntranceNode: machine-root(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">-EntranceNode1: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">-EntranceNode2: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\"></span><br><span class=\"line\">t:threadNum  pq:passQps  bq:blockedQps  tq:totalQps  rt:averageRt  prq: passRequestQps 1mp:1m-passed 1mb:1m-blocked 1mt:1m-total</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2、ClusterBuilderSlot\"><a href=\"#1-2、ClusterBuilderSlot\" class=\"headerlink\" title=\"1.2、ClusterBuilderSlot\"></a>1.2、ClusterBuilderSlot</h2><p>此插槽用于构建资源的 <code>ClusterNode</code> 以及调用来源节点。<code>ClusterNode</code> 保持资源运行统计信息（响应时间、QPS、block 数目、线程数、异常数等）以及原始调用者统计信息列表。来源调用者的名字由 <code>ContextUtil.enter(contextName，origin)</code> 中的 <code>origin</code> 标记。可通过如下命令查看某个资源不同调用者的访问情况：<code>curl http://localhost:8719/origin?id=caller</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id: nodeA</span><br><span class=\"line\">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class=\"line\">1   caller1 0         0         0          0        0     0         0          0        </span><br><span class=\"line\">2   caller2 0         0         0          0        0     0         0          0      </span><br></pre></td></tr></table></figure>\n<h2 id=\"1-3、StatisticSlot\"><a href=\"#1-3、StatisticSlot\" class=\"headerlink\" title=\"1.3、StatisticSlot\"></a>1.3、StatisticSlot</h2><p><code>StatisticSlot</code> 是 <code>Sentinel</code> 的核心功能插槽之一，用于统计实时的调用数据。</p>\n<ul>\n<li><code>clusterNode</code>：资源唯一标识的 <code>ClusterNode</code> 的 <code>runtime</code> 统计 </li>\n<li><code>origin</code>：根据来自不同调用者的统计信息</li>\n<li><code>defaultnode</code>: 根据上下文条目名称和资源 <code>ID</code> 的 <code>runtime</code> 统计</li>\n<li>入口的统计</li>\n</ul>\n<p><code>Sentinel</code> 底层采用高性能的滑动窗口数据结构 <code>LeapArray</code> 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053003.png\" alt=\"滑动窗口\"></p>\n<h2 id=\"1-4、FlowSlot\"><a href=\"#1-4、FlowSlot\" class=\"headerlink\" title=\"1.4、FlowSlot\"></a>1.4、FlowSlot</h2><p>这个 <code>slot</code> 主要根据预设的资源的统计信息，按照固定的次序，依次生效。如果一个资源对应两条或者多条流控规则，则会根据如下次序依次检验，直到全部通过或者有一个规则生效为止:</p>\n<ul>\n<li>指定应用生效的规则，即针对调用方限流的；</li>\n<li>调用方为 other 的规则；</li>\n<li>调用方为 default 的规则。</li>\n</ul>\n<h2 id=\"1-5、DegradeSlot\"><a href=\"#1-5、DegradeSlot\" class=\"headerlink\" title=\"1.5、DegradeSlot\"></a>1.5、DegradeSlot</h2><p>这个 <code>slot</code> 主要针对资源的平均响应时间（RT）以及异常比率，来决定资源是否在接下来的时间被自动熔断掉。</p>\n<h2 id=\"1-6、SystemSlot\"><a href=\"#1-6、SystemSlot\" class=\"headerlink\" title=\"1.6、SystemSlot\"></a>1.6、SystemSlot</h2><p>这个 <code>slot</code> 会根据对于当前系统的整体情况，对入口资源的调用进行动态调配。其原理是让入口的流量和当前系统的预计容量达到一个动态平衡。</p>\n<p>注意系统规则只对入口流量起作用（调用类型为 <code>EntryType.IN</code>），对出口流量无效。可通过 <code>SphU.entry(res, entryType)</code> 指定调用类型，如果不指定，默认是<code>EntryType.OUT</code>。</p>\n<h1 id=\"贰、-核心类解析\"><a href=\"#贰、-核心类解析\" class=\"headerlink\" title=\"贰、 核心类解析\"></a>贰、 核心类解析</h1><h2 id=\"2-1、ProcessorSlotChain\"><a href=\"#2-1、ProcessorSlotChain\" class=\"headerlink\" title=\"2.1、ProcessorSlotChain\"></a>2.1、ProcessorSlotChain</h2><p><code>Sentinel</code> 的核心骨架，将不同的 <code>Slot</code> 按照顺序串在一起（责任链模式），从而将不同的功能（限流、降级、系统保护）组合在一起。<code>slot chain</code> 其实可以分为两部分：统计数据构建部分（statistic）和判断部分（rule checking）。核心结构：</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053001.png\" alt=\"总体框架图\"></p>\n<p>目前的设计是 <code>one slot chain per resource</code>，因为某些 <code>slot</code> 是 <code>per resource</code> 的（比如 <code>NodeSelectorSlot</code>）。</p>\n<h2 id=\"2-2、Context\"><a href=\"#2-2、Context\" class=\"headerlink\" title=\"2.2、Context\"></a>2.2、Context</h2><p><code>Context</code> 代表调用链路上下文，贯穿一次调用链路中的所有 <code>Entry</code>。<code>Context</code> 维持着入口节点（entranceNode）、本次调用链路的 <code>curNode</code>、调用来源（origin）等信息。<code>Context</code> 名称即为调用链路入口名称。</p>\n<p><code>Context</code> 维持的方式：通过 <code>ThreadLocal</code> 传递，只有在入口 <code>enter</code> 的时候生效。由于 <code>Context</code> 是通过 <code>ThreadLocal</code> 传递的，因此对于异步调用链路，线程切换的时候会丢掉 <code>Context</code>，因此需要手动通过 <code>ContextUtil.runOnContext(context, f)</code> 来变换 <code>context</code>。</p>\n<h2 id=\"2-3、Entry\"><a href=\"#2-3、Entry\" class=\"headerlink\" title=\"2.3、Entry\"></a>2.3、Entry</h2><p>每一次资源调用都会创建一个 <code>Entry</code>。<code>Entry</code> 包含了资源名、curNode（当前统计节点）、originNode（来源统计节点）等信息。</p>\n<p><code>CtEntry</code> 为普通的 <code>Entry</code>，在调用 <code>SphU.entry(xxx)</code> 的时候创建。特性：<code>Linked entry within current context（内部维护着 parent 和 child）</code></p>\n<p>需要注意的一点：<code>CtEntry</code> 构造函数中会做调用链的变换，即将当前 <code>Entry</code> 接到传入 <code>Context</code> 的调用链路上（setUpEntryFor）。</p>\n<p>资源调用结束时需要 <code>entry.exit()</code>。<code>exit</code> 操作会过一遍 <code>slot chain exit</code>，恢复调用栈，<code>exit context</code> 然后清空 <code>entry</code> 中的 <code>context</code> 防止重复调用。</p>\n<h2 id=\"2-4、Node\"><a href=\"#2-4、Node\" class=\"headerlink\" title=\"2.4、Node\"></a>2.4、Node</h2><p><code>Sentinel</code> 里面的各种种类的统计节点：</p>\n<ul>\n<li><code>StatisticNode</code>：最为基础的统计节点，包含秒级和分钟级两个滑动窗口结构。</li>\n<li><code>DefaultNode</code>：链路节点，用于统计调用链路上某个资源的数据，维持树状结构。</li>\n<li><code>ClusterNode</code>：簇点，用于统计每个资源全局的数据（不区分调用链路），以及存放该资源的按来源区分的调用数据（类型为 <code>StatisticNode</code>）。特别地，<code>Constants.ENTRY_NODE</code> 节点用于统计全局的入口资源数据。</li>\n<li><code>EntranceNode</code>：入口节点，特殊的链路节点，对应某个 <code>Context</code> 入口的所有调用数据。<code>Constants.ROOT</code> 节点也是入口节点。</li>\n</ul>\n<p>构建的时机：</p>\n<ul>\n<li><code>EntranceNode</code>：在 <code>ContextUtil.enter(xxx)</code> 的时候就创建了，然后塞到 <code>Context</code> 里面。</li>\n<li><code>NodeSelectorSlot</code>：根据 <code>context</code> 创建 <code>DefaultNode</code>，然后 <code>set curNode to context</code>。</li>\n<li><code>ClusterBuilderSlot</code>：首先根据 <code>resourceName</code> 创建 <code>ClusterNode</code>，并且 <code>set clusterNode to defaultNode</code>；然后再根据 <code>origin</code> 创建来源节点（类型为 <code>StatisticNode</code>），并且 <code>set originNode to curEntry</code>。</li>\n</ul>\n<p>几种 <code>Node</code> 的维度（数目）：</p>\n<ul>\n<li><code>ClusterNode</code> 的维度是 <code>resource</code></li>\n<li><code>DefaultNode</code> 的维度是 <code>resource * context</code>，存在每个 <code>NodeSelectorSlot</code> 的 <code>map</code> 里面</li>\n<li><code>EntranceNode</code> 的维度是 <code>context</code>，存在 <code>ContextUtil</code> 类的 <code>contextNameNodeMap</code> 里面</li>\n<li>来源节点（类型为 <code>StatisticNode</code>）的维度是 <code>resource * origin</code>，存在每个 <code>ClusterNode</code> 的 <code>originCountMap</code> 里面</li>\n</ul>\n<h2 id=\"2-5、StatisticSlot\"><a href=\"#2-5、StatisticSlot\" class=\"headerlink\" title=\"2.5、StatisticSlot\"></a>2.5、StatisticSlot</h2><p><code>StatisticSlot</code> 是 <code>Sentinel</code> 最为重要的类之一，用于根据规则判断结果进行相应的统计操作。</p>\n<p><code>entry</code> 的时候：依次执行后面的判断 <code>slot</code>。每个 <code>slot</code> 触发流控的话会抛出异常（<code>BlockException</code> 的子类）。若有 BlockException 抛出，则记录 block 数据；若无异常抛出则算作可通过（pass），记录 pass 数据。</p>\n<p><code>exit</code> 的时候：若无 <code>error（无论是业务异常还是流控异常）</code>，记录 <code>complete（success）</code>以及 <code>RT</code>，线程数<code>-1</code>。</p>\n<p>记录数据的维度：线程数<code>+1</code>、记录当前 <code>DefaultNode</code> 数据、记录对应的 <code>originNode</code> 数据（若存在 <code>origin</code>）、累计 <code>IN</code> 统计数据（若流量类型为 <code>IN</code>）。</p>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践自定义调用链的源码</a> 。</p>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","categories":[{"name":"sentinel","path":"api/categories/sentinel.json"}],"tags":[{"name":"sentinel","path":"api/tags/sentinel.json"}]}
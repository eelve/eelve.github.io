{"title":"Sentinel进阶之流量控制","slug":"Sentinel进阶之流量控制","date":"2021-06-06T04:50:28.000Z","updated":"2023-09-30T08:39:39.682Z","comments":true,"path":"api/articles/Sentinel进阶之流量控制.json","excerpt":null,"covers":["https://image.eelve.com/eblog/warmup.gif","https://image.eelve.com/eblog/queue.gif","https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png"],"content":"<p>【<strong>前面的话</strong>】在前文 <a href=\"https://eelve.com/posts/950c5430.html\">Sentinel进阶之基本原理</a> 中简单介绍了一下<code>Sentinel</code>的基本原理，今天就来具体说一下<code>Sentinel</code>的流量控制。</p>\n<hr>\n<p>壹、概述</p>\n<p><code>FlowSlot</code> 会根据预设的规则，结合前面 <code>NodeSelectorSlot</code>、<code>ClusterNodeBuilderSlot</code>、<code>StatistcSlot</code> 统计出来的实时信息进行流量控制。</p>\n<p>限流的直接表现是在执行 <code>Entry nodeA = SphU.entry(资源名字)</code> 的时候抛出 <code>FlowException</code> 异常。<code>FlowException</code> 是 <code>BlockException</code> 的子类，您可以捕捉 <code>BlockException</code> 来自定义被限流之后的处理逻辑。</p>\n<p>同一个资源可以对应多条限流规则。<code>FlowSlot</code> 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p>\n<p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p>\n<ul>\n<li><code>resource</code>：资源名，即限流规则的作用对象 </li>\n<li><code>count</code>: 限流阈值</li>\n<li><code>grade</code>: 限流阈值类型，QPS 或线程数</li>\n<li><code>strategy</code>: 根据调用关系选择策略</li>\n</ul>\n<p>贰、基于QPS/并发数的流量控制</p>\n<p>流量控制主要有两种统计类型，一种是统计<code>线程数</code>，另外一种则是统计 <code>QPS</code>。类型由 <code>FlowRule.grade</code> 字段来定义。其中，<code>0</code> 代表根据并发数量来限流，<code>1</code> 代表根据 QPS 来进行流量控制。其中<code>线程数</code>、<code>QPS</code> 值，都是由 <code>StatisticSlot</code> 实时统计获取的。</p>\n<p>可以通过下面的命令查看实时统计信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http:&#x2F;&#x2F;localhost:8719&#x2F;cnode?id&#x3D;resourceName</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>8719</code>端口可以通过配置文件修改</p>\n</blockquote>\n<p>输出内容格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">idx id   thread  pass  blocked   success  total Rt   1m-pass   1m-block   1m-all   exeption</span><br><span class=\"line\">2   abc647 0     46     0           46     46   1       2763      0         2763     0</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<ul>\n<li>thread： 代表当前处理该资源的线程数；</li>\n<li>pass： 代表一秒内到来到的请求；</li>\n<li>blocked： 代表一秒内被流量控制的请求数量；</li>\n<li>success： 代表一秒内成功处理完的请求；</li>\n<li>total： 代表到一秒内到来的请求以及被阻止的请求总和；</li>\n<li>RT： 代表一秒内该资源的平均响应时间；</li>\n<li>1m-pass： 则是一分钟内到来的请求；</li>\n<li>1m-block： 则是一分钟内被阻止的请求；</li>\n<li>1m-all： 则是一分钟内到来的请求和被阻止的请求的总和；</li>\n<li>exception： 则是一秒内业务本身异常的总和。</li>\n</ul>\n<h2 id=\"2-1、并发线程数流量控制\"><a href=\"#2-1、并发线程数流量控制\" class=\"headerlink\" title=\"2.1、并发线程数流量控制\"></a>2.1、并发线程数流量控制</h2><p>线程数限流用于保护业务线程数不被耗尽。例如，当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。为应对高线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离），或者使用信号量来控制同时请求的个数（信号量隔离）。这种隔离方案虽然能够控制线程数量，但无法控制请求排队时间。当请求过多时排队也是无益的，直接拒绝能够迅速降低系统压力。Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlowThreadDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger pass = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger block = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger total = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger activeThread = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> seconds = <span class=\"number\">60</span> + <span class=\"number\">40</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> methodBRunningTime = <span class=\"number\">2000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(</span><br><span class=\"line\">            <span class=\"string\">&quot;MethodA will call methodB. After running for a while, methodB becomes fast, &quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;which make methodA also become fast &quot;</span>);</span><br><span class=\"line\">        tick();</span><br><span class=\"line\">        initFlowRule();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">            Thread entryThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                        Entry methodA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            TimeUnit.MILLISECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">                            methodA = SphU.entry(<span class=\"string\">&quot;methodA&quot;</span>);</span><br><span class=\"line\">                            activeThread.incrementAndGet();</span><br><span class=\"line\">                            Entry methodB = SphU.entry(<span class=\"string\">&quot;methodB&quot;</span>);</span><br><span class=\"line\">                            TimeUnit.MILLISECONDS.sleep(methodBRunningTime);</span><br><span class=\"line\">                            methodB.exit();</span><br><span class=\"line\">                            pass.addAndGet(<span class=\"number\">1</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (BlockException e1) &#123;</span><br><span class=\"line\">                            block.incrementAndGet();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e2) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// biz exception</span></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            total.incrementAndGet();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (methodA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                methodA.exit();</span><br><span class=\"line\">                                activeThread.decrementAndGet();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            entryThread.setName(<span class=\"string\">&quot;working thread&quot;</span>);</span><br><span class=\"line\">            entryThread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">initFlowRule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;FlowRule&gt; rules = <span class=\"keyword\">new</span> ArrayList&lt;FlowRule&gt;();</span><br><span class=\"line\">        FlowRule rule1 = <span class=\"keyword\">new</span> FlowRule();</span><br><span class=\"line\">        rule1.setResource(<span class=\"string\">&quot;methodA&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// set limit concurrent thread for &#x27;methodA&#x27; to 20</span></span><br><span class=\"line\">        rule1.setCount(<span class=\"number\">20</span>);</span><br><span class=\"line\">        rule1.setGrade(RuleConstant.FLOW_GRADE_THREAD);</span><br><span class=\"line\">        rule1.setLimitApp(<span class=\"string\">&quot;default&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        rules.add(rule1);</span><br><span class=\"line\">        FlowRuleManager.loadRules(rules);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tick</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread timer = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> TimerTask());</span><br><span class=\"line\">        timer.setName(<span class=\"string\">&quot;sentinel-timer-task&quot;</span>);</span><br><span class=\"line\">        timer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;begin to statistic!!!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldTotal = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldPass = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldBlock = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalTotal = total.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondTotal = globalTotal - oldTotal;</span><br><span class=\"line\">                oldTotal = globalTotal;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalPass = pass.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondPass = globalPass - oldPass;</span><br><span class=\"line\">                oldPass = globalPass;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalBlock = block.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondBlock = globalBlock - oldBlock;</span><br><span class=\"line\">                oldBlock = globalBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(seconds + <span class=\"string\">&quot; total qps is: &quot;</span> + oneSecondTotal);</span><br><span class=\"line\">                System.out.println(TimeUtil.currentTimeMillis() + <span class=\"string\">&quot;, total:&quot;</span> + oneSecondTotal</span><br><span class=\"line\">                    + <span class=\"string\">&quot;, pass:&quot;</span> + oneSecondPass</span><br><span class=\"line\">                    + <span class=\"string\">&quot;, block:&quot;</span> + oneSecondBlock</span><br><span class=\"line\">                    + <span class=\"string\">&quot; activeThread:&quot;</span> + activeThread.get());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (seconds-- &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    stop = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (seconds == <span class=\"number\">40</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;method B is running much faster; more requests are allowed to pass&quot;</span>);</span><br><span class=\"line\">                    methodBRunningTime = <span class=\"number\">20</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> cost = System.currentTimeMillis() - start;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;time cost: &quot;</span> + cost + <span class=\"string\">&quot; ms&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;total:&quot;</span> + total.get() + <span class=\"string\">&quot;, pass:&quot;</span> + pass.get()</span><br><span class=\"line\">                + <span class=\"string\">&quot;, block:&quot;</span> + block.get());</span><br><span class=\"line\">            System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、QPS流量控制\"><a href=\"#2-2、QPS流量控制\" class=\"headerlink\" title=\"2.2、QPS流量控制\"></a>2.2、QPS流量控制</h2><p>当 <code>QPS</code> 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括下面 3 种，对应 <code>FlowRule</code> 中的 <code>controlBehavior</code> 字段：</p>\n<ul>\n<li><p>1、直接拒绝（<code>RuleConstant.CONTROL_BEHAVIOR_DEFAULT</code>）方式。该方式是默认的流量控制方式，当<code>QPS</code>超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。</p>\n</li>\n<li><p>2、冷启动（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式。该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</p>\n<p>  通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：<br>  <img src=\"https://image.eelve.com/eblog/warmup.gif\" alt=\"冷启动\"></p>\n</li>\n<li><p>3、匀速器（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p>\n<p>  <img src=\"https://image.eelve.com/eblog/queue.gif\" alt=\"排队\"></p>\n<p>  这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p>\n</li>\n</ul>\n<p>叁、基于调用关系的流量控制</p>\n<p>调用关系包括调用方、被调用方；方法又可能会调用其它方法，形成一个调用链路的层次关系。<code>Sentinel</code> 通过 <code>NodeSelectorSlot</code> 建立不同资源间的调用的关系，并且通过 <code>ClusterNodeBuilderSlot</code> 记录每个资源的实时统计信息。</p>\n<p>有了调用链路的统计信息，我们可以衍生出多种流量控制手段。</p>\n<h2 id=\"3-1-根据调用方限流\"><a href=\"#3-1-根据调用方限流\" class=\"headerlink\" title=\"3.1 根据调用方限流\"></a>3.1 根据调用方限流</h2><p><code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数标明了调用方身份。这些信息会在 <code>ClusterBuilderSlot</code> 中被统计。可通过以下命令来展示不同的调用方对同一个资源的调用数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http:&#x2F;&#x2F;localhost:8719&#x2F;origin?id&#x3D;nodeA</span><br></pre></td></tr></table></figure>\n<p>调用数据示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id: nodeA</span><br><span class=\"line\">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class=\"line\">1   caller1 0         0         0          0        0     0         0          0</span><br><span class=\"line\">2   caller2 0         0         0          0        0     0         0          0</span><br></pre></td></tr></table></figure>\n<p>上面这个命令展示了资源名为 <code>nodeA</code> 的资源被两个不同的调用方调用的统计。</p>\n<p>限流规则中的 <code>limitApp</code> 字段用于根据调用方进行流量控制。该字段的值有以下三种选项，分别对应不同的场景：</p>\n<ul>\n<li><code>default</code>：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。</li>\n<li><code>&#123;some_origin_name&#125;</code>：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 <code>NodeA</code> 配置了一条针对调用者<code>caller1</code>的规则，那么当且仅当来自 <code>caller1</code> 对 <code>NodeA</code> 的请求才会触发流量控制。</li>\n<li><code>other</code>：表示针对除 <code>&#123;some_origin_name&#125;</code> 以外的其余调用方的流量进行流量控制。例如，资源<code>NodeA</code>配置了一条针对调用者 <code>caller1</code> 的限流规则，同时又配置了一条调用者为 <code>other</code> 的规则，那么任意来自非 <code>caller1</code> 对 <code>NodeA</code> 的调用，都不能超过 <code>other</code> 这条规则定义的阈值。</li>\n</ul>\n<blockquote>\n<p>同一个资源名可以配置多条规则，规则的生效顺序为：{some_origin_name} &gt; other &gt; default</p>\n</blockquote>\n<h2 id=\"3-2-根据调用链路入口限流：链路限流\"><a href=\"#3-2-根据调用链路入口限流：链路限流\" class=\"headerlink\" title=\"3.2 根据调用链路入口限流：链路限流\"></a>3.2 根据调用链路入口限流：链路限流</h2><p><code>NodeSelectorSlot</code> 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 <code>machine-root</code> 的虚拟节点，调用链的入口都是这个虚节点的子节点。</p>\n<p>一棵典型的调用树如下图所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">          machine-root</span><br><span class=\"line\">              &#x2F;       \\</span><br><span class=\"line\">             &#x2F;         \\</span><br><span class=\"line\">       Entrance1     Entrance2</span><br><span class=\"line\">          &#x2F;             \\</span><br><span class=\"line\">         &#x2F;               \\</span><br><span class=\"line\">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure>\n<p>上图中来自入口 <code>Entrance1</code> 和 <code>Entrance2</code> 的请求都调用到了资源 <code>NodeA</code>，<code>Sentinel</code> 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 <code>FlowRule.strategy</code> 为 <code>RuleConstant.CHAIN</code>，同时设置 <code>FlowRule.ref_identity</code> 为 <code>Entrance1</code> 来表示只有从入口 <code>Entrance1</code> 的调用才会记录到 <code>NodeA</code> 的限流统计当中，而对来自 <code>Entrance2</code> 的调用漠不关心。</p>\n<p>调用链的入口是通过 <code>API</code> 方法 <code>ContextUtil.enter(name)</code> 定义的。</p>\n<h2 id=\"3-3-具有关系的资源流量控制：关联流量控制\"><a href=\"#3-3-具有关系的资源流量控制：关联流量控制\" class=\"headerlink\" title=\"3.3 具有关系的资源流量控制：关联流量控制\"></a>3.3 具有关系的资源流量控制：关联流量控制</h2><p>当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，<code>read_db</code> 和 <code>write_db</code> 这两个资源分别代表数据库读写，我们可以给 <code>read_db</code> 设置限流规则来达到写优先的目的：设置 <code>FlowRule.strategy</code> 为 <code>RuleConstant.RELATE</code> 同时设置 <code>FlowRule.ref_identity</code> 为 <code>write_db</code>。这样当写库操作过于频繁时，读数据的请求会被限流。</p>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践的源码</a> ,包括流量控制和初始规则加载等等。</p>\n<p>另外在使用<code>API</code>去加载规则的时候，发现存在规则不生效的时候，通过调试发现：<code>Sentinel</code>在加载规则到内存中的时候会校验规则的合法性，如果规则不合法，该规则将不被加载。</p>\n<p>具体可以查看<code>com.alibaba.csp.sentinel.property#configLoad</code>方法的实现类中参数校验方法，下面贴出<code>FlowRule</code> 的校验方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Check whether provided flow rule is valid.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param rule flow rule to check</span><br><span class=\"line\"> * @return true if valid, otherwise false</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public static boolean isValidRule(FlowRule rule) &#123;</span><br><span class=\"line\">    boolean baseValid &#x3D; rule !&#x3D; null &amp;&amp; !StringUtil.isBlank(rule.getResource()) &amp;&amp; rule.getCount() &gt;&#x3D; 0</span><br><span class=\"line\">        &amp;&amp; rule.getGrade() &gt;&#x3D; 0 &amp;&amp; rule.getStrategy() &gt;&#x3D; 0 &amp;&amp; rule.getControlBehavior() &gt;&#x3D; 0;</span><br><span class=\"line\">    if (!baseValid) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; Check strategy and control (shaping) behavior.</span><br><span class=\"line\">    return checkClusterField(rule) &amp;&amp; checkStrategyField(rule) &amp;&amp; checkControlBehaviorField(rule);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static boolean checkClusterField(&#x2F;*@NonNull*&#x2F; FlowRule rule) &#123;</span><br><span class=\"line\">    if (!rule.isClusterMode()) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ClusterFlowConfig clusterConfig &#x3D; rule.getClusterConfig();</span><br><span class=\"line\">    if (clusterConfig &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!validClusterRuleId(clusterConfig.getFlowId())) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!isWindowConfigValid(clusterConfig.getSampleCount(), clusterConfig.getWindowIntervalMs())) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    switch (clusterConfig.getStrategy()) &#123;</span><br><span class=\"line\">        case ClusterRuleConstant.FLOW_CLUSTER_STRATEGY_NORMAL:</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static boolean isWindowConfigValid(int sampleCount, int windowIntervalMs) &#123;</span><br><span class=\"line\">    return sampleCount &gt; 0 &amp;&amp; windowIntervalMs &gt; 0 &amp;&amp; windowIntervalMs % sampleCount &#x3D;&#x3D; 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static boolean checkStrategyField(&#x2F;*@NonNull*&#x2F; FlowRule rule) &#123;</span><br><span class=\"line\">    if (rule.getStrategy() &#x3D;&#x3D; RuleConstant.STRATEGY_RELATE || rule.getStrategy() &#x3D;&#x3D; RuleConstant.STRATEGY_CHAIN) &#123;</span><br><span class=\"line\">        return StringUtil.isNotBlank(rule.getRefResource());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static boolean checkControlBehaviorField(&#x2F;*@NonNull*&#x2F; FlowRule rule) &#123;</span><br><span class=\"line\">    switch (rule.getControlBehavior()) &#123;</span><br><span class=\"line\">        case RuleConstant.CONTROL_BEHAVIOR_WARM_UP:</span><br><span class=\"line\">            return rule.getWarmUpPeriodSec() &gt; 0;</span><br><span class=\"line\">        case RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER:</span><br><span class=\"line\">            return rule.getMaxQueueingTimeMs() &gt; 0;</span><br><span class=\"line\">        case RuleConstant.CONTROL_BEHAVIOR_WARM_UP_RATE_LIMITER:</span><br><span class=\"line\">            return rule.getWarmUpPeriodSec() &gt; 0 &amp;&amp; rule.getMaxQueueingTimeMs() &gt; 0;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","more":"<p>【<strong>前面的话</strong>】在前文 <a href=\"https://eelve.com/posts/950c5430.html\">Sentinel进阶之基本原理</a> 中简单介绍了一下<code>Sentinel</code>的基本原理，今天就来具体说一下<code>Sentinel</code>的流量控制。</p>\n<hr>\n<p>壹、概述</p>\n<p><code>FlowSlot</code> 会根据预设的规则，结合前面 <code>NodeSelectorSlot</code>、<code>ClusterNodeBuilderSlot</code>、<code>StatistcSlot</code> 统计出来的实时信息进行流量控制。</p>\n<p>限流的直接表现是在执行 <code>Entry nodeA = SphU.entry(资源名字)</code> 的时候抛出 <code>FlowException</code> 异常。<code>FlowException</code> 是 <code>BlockException</code> 的子类，您可以捕捉 <code>BlockException</code> 来自定义被限流之后的处理逻辑。</p>\n<p>同一个资源可以对应多条限流规则。<code>FlowSlot</code> 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p>\n<p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p>\n<ul>\n<li><code>resource</code>：资源名，即限流规则的作用对象 </li>\n<li><code>count</code>: 限流阈值</li>\n<li><code>grade</code>: 限流阈值类型，QPS 或线程数</li>\n<li><code>strategy</code>: 根据调用关系选择策略</li>\n</ul>\n<p>贰、基于QPS/并发数的流量控制</p>\n<p>流量控制主要有两种统计类型，一种是统计<code>线程数</code>，另外一种则是统计 <code>QPS</code>。类型由 <code>FlowRule.grade</code> 字段来定义。其中，<code>0</code> 代表根据并发数量来限流，<code>1</code> 代表根据 QPS 来进行流量控制。其中<code>线程数</code>、<code>QPS</code> 值，都是由 <code>StatisticSlot</code> 实时统计获取的。</p>\n<p>可以通过下面的命令查看实时统计信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http:&#x2F;&#x2F;localhost:8719&#x2F;cnode?id&#x3D;resourceName</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>8719</code>端口可以通过配置文件修改</p>\n</blockquote>\n<p>输出内容格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">idx id   thread  pass  blocked   success  total Rt   1m-pass   1m-block   1m-all   exeption</span><br><span class=\"line\">2   abc647 0     46     0           46     46   1       2763      0         2763     0</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<ul>\n<li>thread： 代表当前处理该资源的线程数；</li>\n<li>pass： 代表一秒内到来到的请求；</li>\n<li>blocked： 代表一秒内被流量控制的请求数量；</li>\n<li>success： 代表一秒内成功处理完的请求；</li>\n<li>total： 代表到一秒内到来的请求以及被阻止的请求总和；</li>\n<li>RT： 代表一秒内该资源的平均响应时间；</li>\n<li>1m-pass： 则是一分钟内到来的请求；</li>\n<li>1m-block： 则是一分钟内被阻止的请求；</li>\n<li>1m-all： 则是一分钟内到来的请求和被阻止的请求的总和；</li>\n<li>exception： 则是一秒内业务本身异常的总和。</li>\n</ul>\n<h2 id=\"2-1、并发线程数流量控制\"><a href=\"#2-1、并发线程数流量控制\" class=\"headerlink\" title=\"2.1、并发线程数流量控制\"></a>2.1、并发线程数流量控制</h2><p>线程数限流用于保护业务线程数不被耗尽。例如，当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。为应对高线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离），或者使用信号量来控制同时请求的个数（信号量隔离）。这种隔离方案虽然能够控制线程数量，但无法控制请求排队时间。当请求过多时排队也是无益的，直接拒绝能够迅速降低系统压力。Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlowThreadDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger pass = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger block = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger total = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger activeThread = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> seconds = <span class=\"number\">60</span> + <span class=\"number\">40</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> methodBRunningTime = <span class=\"number\">2000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(</span><br><span class=\"line\">            <span class=\"string\">&quot;MethodA will call methodB. After running for a while, methodB becomes fast, &quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;which make methodA also become fast &quot;</span>);</span><br><span class=\"line\">        tick();</span><br><span class=\"line\">        initFlowRule();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">            Thread entryThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                        Entry methodA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            TimeUnit.MILLISECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">                            methodA = SphU.entry(<span class=\"string\">&quot;methodA&quot;</span>);</span><br><span class=\"line\">                            activeThread.incrementAndGet();</span><br><span class=\"line\">                            Entry methodB = SphU.entry(<span class=\"string\">&quot;methodB&quot;</span>);</span><br><span class=\"line\">                            TimeUnit.MILLISECONDS.sleep(methodBRunningTime);</span><br><span class=\"line\">                            methodB.exit();</span><br><span class=\"line\">                            pass.addAndGet(<span class=\"number\">1</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (BlockException e1) &#123;</span><br><span class=\"line\">                            block.incrementAndGet();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e2) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// biz exception</span></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            total.incrementAndGet();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (methodA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                methodA.exit();</span><br><span class=\"line\">                                activeThread.decrementAndGet();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            entryThread.setName(<span class=\"string\">&quot;working thread&quot;</span>);</span><br><span class=\"line\">            entryThread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">initFlowRule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;FlowRule&gt; rules = <span class=\"keyword\">new</span> ArrayList&lt;FlowRule&gt;();</span><br><span class=\"line\">        FlowRule rule1 = <span class=\"keyword\">new</span> FlowRule();</span><br><span class=\"line\">        rule1.setResource(<span class=\"string\">&quot;methodA&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// set limit concurrent thread for &#x27;methodA&#x27; to 20</span></span><br><span class=\"line\">        rule1.setCount(<span class=\"number\">20</span>);</span><br><span class=\"line\">        rule1.setGrade(RuleConstant.FLOW_GRADE_THREAD);</span><br><span class=\"line\">        rule1.setLimitApp(<span class=\"string\">&quot;default&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        rules.add(rule1);</span><br><span class=\"line\">        FlowRuleManager.loadRules(rules);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tick</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread timer = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> TimerTask());</span><br><span class=\"line\">        timer.setName(<span class=\"string\">&quot;sentinel-timer-task&quot;</span>);</span><br><span class=\"line\">        timer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;begin to statistic!!!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldTotal = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldPass = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldBlock = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalTotal = total.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondTotal = globalTotal - oldTotal;</span><br><span class=\"line\">                oldTotal = globalTotal;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalPass = pass.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondPass = globalPass - oldPass;</span><br><span class=\"line\">                oldPass = globalPass;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalBlock = block.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondBlock = globalBlock - oldBlock;</span><br><span class=\"line\">                oldBlock = globalBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(seconds + <span class=\"string\">&quot; total qps is: &quot;</span> + oneSecondTotal);</span><br><span class=\"line\">                System.out.println(TimeUtil.currentTimeMillis() + <span class=\"string\">&quot;, total:&quot;</span> + oneSecondTotal</span><br><span class=\"line\">                    + <span class=\"string\">&quot;, pass:&quot;</span> + oneSecondPass</span><br><span class=\"line\">                    + <span class=\"string\">&quot;, block:&quot;</span> + oneSecondBlock</span><br><span class=\"line\">                    + <span class=\"string\">&quot; activeThread:&quot;</span> + activeThread.get());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (seconds-- &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    stop = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (seconds == <span class=\"number\">40</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;method B is running much faster; more requests are allowed to pass&quot;</span>);</span><br><span class=\"line\">                    methodBRunningTime = <span class=\"number\">20</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> cost = System.currentTimeMillis() - start;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;time cost: &quot;</span> + cost + <span class=\"string\">&quot; ms&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;total:&quot;</span> + total.get() + <span class=\"string\">&quot;, pass:&quot;</span> + pass.get()</span><br><span class=\"line\">                + <span class=\"string\">&quot;, block:&quot;</span> + block.get());</span><br><span class=\"line\">            System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、QPS流量控制\"><a href=\"#2-2、QPS流量控制\" class=\"headerlink\" title=\"2.2、QPS流量控制\"></a>2.2、QPS流量控制</h2><p>当 <code>QPS</code> 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括下面 3 种，对应 <code>FlowRule</code> 中的 <code>controlBehavior</code> 字段：</p>\n<ul>\n<li><p>1、直接拒绝（<code>RuleConstant.CONTROL_BEHAVIOR_DEFAULT</code>）方式。该方式是默认的流量控制方式，当<code>QPS</code>超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。</p>\n</li>\n<li><p>2、冷启动（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式。该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</p>\n<p>  通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：<br>  <img src=\"https://image.eelve.com/eblog/warmup.gif\" alt=\"冷启动\"></p>\n</li>\n<li><p>3、匀速器（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p>\n<p>  <img src=\"https://image.eelve.com/eblog/queue.gif\" alt=\"排队\"></p>\n<p>  这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p>\n</li>\n</ul>\n<p>叁、基于调用关系的流量控制</p>\n<p>调用关系包括调用方、被调用方；方法又可能会调用其它方法，形成一个调用链路的层次关系。<code>Sentinel</code> 通过 <code>NodeSelectorSlot</code> 建立不同资源间的调用的关系，并且通过 <code>ClusterNodeBuilderSlot</code> 记录每个资源的实时统计信息。</p>\n<p>有了调用链路的统计信息，我们可以衍生出多种流量控制手段。</p>\n<h2 id=\"3-1-根据调用方限流\"><a href=\"#3-1-根据调用方限流\" class=\"headerlink\" title=\"3.1 根据调用方限流\"></a>3.1 根据调用方限流</h2><p><code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数标明了调用方身份。这些信息会在 <code>ClusterBuilderSlot</code> 中被统计。可通过以下命令来展示不同的调用方对同一个资源的调用数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http:&#x2F;&#x2F;localhost:8719&#x2F;origin?id&#x3D;nodeA</span><br></pre></td></tr></table></figure>\n<p>调用数据示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id: nodeA</span><br><span class=\"line\">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class=\"line\">1   caller1 0         0         0          0        0     0         0          0</span><br><span class=\"line\">2   caller2 0         0         0          0        0     0         0          0</span><br></pre></td></tr></table></figure>\n<p>上面这个命令展示了资源名为 <code>nodeA</code> 的资源被两个不同的调用方调用的统计。</p>\n<p>限流规则中的 <code>limitApp</code> 字段用于根据调用方进行流量控制。该字段的值有以下三种选项，分别对应不同的场景：</p>\n<ul>\n<li><code>default</code>：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。</li>\n<li><code>&#123;some_origin_name&#125;</code>：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 <code>NodeA</code> 配置了一条针对调用者<code>caller1</code>的规则，那么当且仅当来自 <code>caller1</code> 对 <code>NodeA</code> 的请求才会触发流量控制。</li>\n<li><code>other</code>：表示针对除 <code>&#123;some_origin_name&#125;</code> 以外的其余调用方的流量进行流量控制。例如，资源<code>NodeA</code>配置了一条针对调用者 <code>caller1</code> 的限流规则，同时又配置了一条调用者为 <code>other</code> 的规则，那么任意来自非 <code>caller1</code> 对 <code>NodeA</code> 的调用，都不能超过 <code>other</code> 这条规则定义的阈值。</li>\n</ul>\n<blockquote>\n<p>同一个资源名可以配置多条规则，规则的生效顺序为：{some_origin_name} &gt; other &gt; default</p>\n</blockquote>\n<h2 id=\"3-2-根据调用链路入口限流：链路限流\"><a href=\"#3-2-根据调用链路入口限流：链路限流\" class=\"headerlink\" title=\"3.2 根据调用链路入口限流：链路限流\"></a>3.2 根据调用链路入口限流：链路限流</h2><p><code>NodeSelectorSlot</code> 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 <code>machine-root</code> 的虚拟节点，调用链的入口都是这个虚节点的子节点。</p>\n<p>一棵典型的调用树如下图所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">          machine-root</span><br><span class=\"line\">              &#x2F;       \\</span><br><span class=\"line\">             &#x2F;         \\</span><br><span class=\"line\">       Entrance1     Entrance2</span><br><span class=\"line\">          &#x2F;             \\</span><br><span class=\"line\">         &#x2F;               \\</span><br><span class=\"line\">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure>\n<p>上图中来自入口 <code>Entrance1</code> 和 <code>Entrance2</code> 的请求都调用到了资源 <code>NodeA</code>，<code>Sentinel</code> 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 <code>FlowRule.strategy</code> 为 <code>RuleConstant.CHAIN</code>，同时设置 <code>FlowRule.ref_identity</code> 为 <code>Entrance1</code> 来表示只有从入口 <code>Entrance1</code> 的调用才会记录到 <code>NodeA</code> 的限流统计当中，而对来自 <code>Entrance2</code> 的调用漠不关心。</p>\n<p>调用链的入口是通过 <code>API</code> 方法 <code>ContextUtil.enter(name)</code> 定义的。</p>\n<h2 id=\"3-3-具有关系的资源流量控制：关联流量控制\"><a href=\"#3-3-具有关系的资源流量控制：关联流量控制\" class=\"headerlink\" title=\"3.3 具有关系的资源流量控制：关联流量控制\"></a>3.3 具有关系的资源流量控制：关联流量控制</h2><p>当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，<code>read_db</code> 和 <code>write_db</code> 这两个资源分别代表数据库读写，我们可以给 <code>read_db</code> 设置限流规则来达到写优先的目的：设置 <code>FlowRule.strategy</code> 为 <code>RuleConstant.RELATE</code> 同时设置 <code>FlowRule.ref_identity</code> 为 <code>write_db</code>。这样当写库操作过于频繁时，读数据的请求会被限流。</p>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践的源码</a> ,包括流量控制和初始规则加载等等。</p>\n<p>另外在使用<code>API</code>去加载规则的时候，发现存在规则不生效的时候，通过调试发现：<code>Sentinel</code>在加载规则到内存中的时候会校验规则的合法性，如果规则不合法，该规则将不被加载。</p>\n<p>具体可以查看<code>com.alibaba.csp.sentinel.property#configLoad</code>方法的实现类中参数校验方法，下面贴出<code>FlowRule</code> 的校验方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Check whether provided flow rule is valid.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param rule flow rule to check</span><br><span class=\"line\"> * @return true if valid, otherwise false</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public static boolean isValidRule(FlowRule rule) &#123;</span><br><span class=\"line\">    boolean baseValid &#x3D; rule !&#x3D; null &amp;&amp; !StringUtil.isBlank(rule.getResource()) &amp;&amp; rule.getCount() &gt;&#x3D; 0</span><br><span class=\"line\">        &amp;&amp; rule.getGrade() &gt;&#x3D; 0 &amp;&amp; rule.getStrategy() &gt;&#x3D; 0 &amp;&amp; rule.getControlBehavior() &gt;&#x3D; 0;</span><br><span class=\"line\">    if (!baseValid) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; Check strategy and control (shaping) behavior.</span><br><span class=\"line\">    return checkClusterField(rule) &amp;&amp; checkStrategyField(rule) &amp;&amp; checkControlBehaviorField(rule);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static boolean checkClusterField(&#x2F;*@NonNull*&#x2F; FlowRule rule) &#123;</span><br><span class=\"line\">    if (!rule.isClusterMode()) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ClusterFlowConfig clusterConfig &#x3D; rule.getClusterConfig();</span><br><span class=\"line\">    if (clusterConfig &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!validClusterRuleId(clusterConfig.getFlowId())) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!isWindowConfigValid(clusterConfig.getSampleCount(), clusterConfig.getWindowIntervalMs())) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    switch (clusterConfig.getStrategy()) &#123;</span><br><span class=\"line\">        case ClusterRuleConstant.FLOW_CLUSTER_STRATEGY_NORMAL:</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static boolean isWindowConfigValid(int sampleCount, int windowIntervalMs) &#123;</span><br><span class=\"line\">    return sampleCount &gt; 0 &amp;&amp; windowIntervalMs &gt; 0 &amp;&amp; windowIntervalMs % sampleCount &#x3D;&#x3D; 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static boolean checkStrategyField(&#x2F;*@NonNull*&#x2F; FlowRule rule) &#123;</span><br><span class=\"line\">    if (rule.getStrategy() &#x3D;&#x3D; RuleConstant.STRATEGY_RELATE || rule.getStrategy() &#x3D;&#x3D; RuleConstant.STRATEGY_CHAIN) &#123;</span><br><span class=\"line\">        return StringUtil.isNotBlank(rule.getRefResource());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static boolean checkControlBehaviorField(&#x2F;*@NonNull*&#x2F; FlowRule rule) &#123;</span><br><span class=\"line\">    switch (rule.getControlBehavior()) &#123;</span><br><span class=\"line\">        case RuleConstant.CONTROL_BEHAVIOR_WARM_UP:</span><br><span class=\"line\">            return rule.getWarmUpPeriodSec() &gt; 0;</span><br><span class=\"line\">        case RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER:</span><br><span class=\"line\">            return rule.getMaxQueueingTimeMs() &gt; 0;</span><br><span class=\"line\">        case RuleConstant.CONTROL_BEHAVIOR_WARM_UP_RATE_LIMITER:</span><br><span class=\"line\">            return rule.getWarmUpPeriodSec() &gt; 0 &amp;&amp; rule.getMaxQueueingTimeMs() &gt; 0;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","categories":[{"name":"sentinel","path":"api/categories/sentinel.json"}],"tags":[{"name":"sentinel","path":"api/tags/sentinel.json"}]}
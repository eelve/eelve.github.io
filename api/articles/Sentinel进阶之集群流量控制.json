{"title":"Sentinel进阶之集群流量控制","slug":"Sentinel进阶之集群流量控制","date":"2021-07-10T01:04:09.000Z","updated":"2021-07-19T02:33:46.616Z","comments":true,"path":"api/articles/Sentinel进阶之集群流量控制.json","excerpt":null,"covers":["https://image.eelve.com/eblog/2021071001.png","https://image.eelve.com/eblog/2021071002.png","https://image.eelve.com/eblog/2021071003.png","https://image.eelve.com/eblog/2021071004.png","https://image.eelve.com/eblog/2021071005.png","https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png"],"content":"<p>【<strong>前面的话</strong>】在前面几篇文章中简单介绍了一下<code>Sentinel</code>的功能都是针对单机的，今天就来继续说一下Sentinel的集群流量控制。</p>\n<hr>\n<h1 id=\"壹、集群流控介绍\"><a href=\"#壹、集群流控介绍\" class=\"headerlink\" title=\"壹、集群流控介绍\"></a>壹、集群流控介绍</h1><h2 id=\"1-1、介绍\"><a href=\"#1-1、介绍\" class=\"headerlink\" title=\"1.1、介绍\"></a>1.1、介绍</h2><p>为什么要使用集群流控呢？假设我们希望给某个用户限制调用某个 API 的总 QPS 为 50，但机器数可能很多（比如有 100 台）。这时候我们很自然地就想到，找一个 server 来专门来统计总的调用量，其它的实例都与这台 server 通信来判断是否可以调用。这就是最基础的集群流控的方式。</p>\n<p>另外集群流控还可以解决流量不均匀导致总体限流效果不佳的问题。假设集群中有 10 台机器，我们给每台机器设置单机限流阈值为 10 QPS，理想情况下整个集群的限流阈值就为 100 QPS。不过实际情况下流量到每台机器可能会不均匀，会导致总量没有到的情况下某些机器就开始限流。因此仅靠单机维度去限制的话会无法精确地限制总体流量。而集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。</p>\n<p>集群流控中共有两种身份：</p>\n<ul>\n<li>Token Client：集群流控客户端，用于向所属 Token Server 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。</li>\n<li>Token Server：即集群流控服务端，处理来自 Token Client 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。</li>\n</ul>\n<p><img src=\"https://image.eelve.com/eblog/2021071001.png\" alt=\"结构示意图\"></p>\n<h2 id=\"1-2、模块结构\"><a href=\"#1-2、模块结构\" class=\"headerlink\" title=\"1.2、模块结构\"></a>1.2、模块结构</h2><p>Sentinel 1.4.0 开始引入了集群流控模块，主要包含以下几部分：</p>\n<ul>\n<li><code>sentinel-cluster-common-default</code>: 公共模块，包含公共接口和实体</li>\n<li><code>sentinel-cluster-client-default</code>: 默认集群流控 client 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展</li>\n<li><code>sentinel-cluster-server-default</code>: 默认集群流控 server 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展；同时提供扩展接口对接规则判断的具体实现（TokenService），默认实现是复用 sentinel-core 的相关逻辑</li>\n</ul>\n<blockquote>\n<p>注意：集群流控模块要求 JDK 版本最低为 1.7。</p>\n</blockquote>\n<h1 id=\"贰、集群流控规则\"><a href=\"#贰、集群流控规则\" class=\"headerlink\" title=\"贰、集群流控规则\"></a>贰、集群流控规则</h1><p><code>FlowRule</code>添加了两个字段用于集群限流相关配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> clusterMode; <span class=\"comment\">// 标识是否为集群限流配置</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ClusterFlowConfig clusterConfig; <span class=\"comment\">// 集群限流相关配置项</span></span><br></pre></td></tr></table></figure>\n<p>其中用一个专门的 <code>ClusterFlowConfig</code> 代表集群限流相关配置项，以与现有规则配置项分开：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局唯一的规则 ID，由集群限流管控端分配.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Long flowId;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阈值模式，默认（0）为单机均摊，1 为全局阈值.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> thresholdType = ClusterRuleConstant.FLOW_THRESHOLD_AVG_LOCAL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> strategy = ClusterRuleConstant.FLOW_CLUSTER_STRATEGY_NORMAL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 client 连接失败或通信失败时，是否退化到本地的限流模式</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> fallbackToLocalWhenFail = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>flowId</code> 代表全局唯一的规则 <code>ID</code>，<code>Sentinel</code> 集群限流服务端通过此 <code>ID</code> 来区分各个规则，因此务必保持全局唯一。一般 <code>flowId</code> 由统一的管控端进行分配，或写入至 <code>DB</code> 时生成。</li>\n<li><code>thresholdType</code> 代表集群限流阈值模式。其中单机均摊模式下配置的阈值等同于单机能够承受的限额，<code>token server</code> 会根据客户端对应的 <code>namespace</code>（默认为 <code>project.name</code> 定义的应用名）下的连接数来计算总的阈值（比如独立模式下有 3 个 client 连接到了 token server，然后配的单机均摊阈值为 10，则计算出的集群总量就为 30）；而全局模式下配置的阈值等同于整个集群的总阈值。</li>\n</ul>\n<p><code>ParamFlowRule</code> 热点参数限流相关的集群配置与 <code>FlowRule</code> 相似。</p>\n<h1 id=\"叁、集群流控配置\"><a href=\"#叁、集群流控配置\" class=\"headerlink\" title=\"叁、集群流控配置\"></a>叁、集群流控配置</h1><h2 id=\"3-1、配置方式\"><a href=\"#3-1、配置方式\" class=\"headerlink\" title=\"3.1、配置方式\"></a>3.1、配置方式</h2><blockquote>\n<p>在集群流控的场景下，推荐使用动态规则源来动态地管理规则。</p>\n</blockquote>\n<p>对于客户端，按照原有的方式来向 FlowRuleManager 和 ParamFlowRuleManager 注册动态规则源，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class=\"keyword\">new</span> NacosDataSource&lt;&gt;(remoteAddress, groupId, dataId, parser);</span><br><span class=\"line\">FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br></pre></td></tr></table></figure>\n<p>对于集群流控 <code>token server</code>，由于集群限流服务端有作用域（namespace）的概念，因此我们需要注册一个自动根据 <code>namespace</code> 生成动态规则源的 <code>PropertySupplier</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Supplier 类型：接受 namespace，返回生成的动态规则源，类型为 SentinelProperty&lt;List&lt;FlowRule&gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// ClusterFlowRuleManager 针对集群限流规则，ClusterParamFlowRuleManager 针对集群热点规则，配置方式类似</span></span><br><span class=\"line\">ClusterFlowRuleManager.setPropertySupplier(namespace -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SomeDataSource(namespace).getProperty();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然后每当集群限流服务端 <code>namespace set</code> 产生变更时，<code>Sentinel</code> 会自动针对新加入的 <code>namespace</code> 生成动态规则源并进行自动监听，并删除旧的不需要的规则源。</p>\n<h2 id=\"3-2、集群限流服务端\"><a href=\"#3-2、集群限流服务端\" class=\"headerlink\" title=\"3.2、集群限流服务端\"></a>3.2、集群限流服务端</h2><p>要想使用集群限流服务端，必须引入集群限流 server 相关依赖：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;sentinel-cluster-server-default&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.7.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3、启动方式\"><a href=\"#3-3、启动方式\" class=\"headerlink\" title=\"3.3、启动方式\"></a>3.3、启动方式</h2><p><code>Sentinel</code> 集群限流服务端有两种启动方式：</p>\n<ul>\n<li>独立模式（Alone），即作为独立的 <code>token server</code> 进程启动，独立部署，隔离性好，但是需要额外的部署操作。独立模式适合作为 <code>Global Rate Limiter</code> 给集群提供流控服务。</li>\n</ul>\n<p><img src=\"https://image.eelve.com/eblog/2021071002.png\" alt=\"独立模式\"></p>\n<ul>\n<li>嵌入模式（Embedded），即作为内置的 <code>token server</code> 与服务在同一进程中启动。在此模式下，集群中各个实例都是对等的，<code>token server</code> 和 <code>client</code> 可以随时进行转变，因此无需单独部署，灵活性比较好。但是隔离性不佳，需要限制 <code>token server</code> 的总 <code>QPS</code>，防止影响应用本身。嵌入模式适合某个应用集群内部的流控。</li>\n</ul>\n<p><img src=\"https://image.eelve.com/eblog/2021071003.png\" alt=\"嵌入模式\"></p>\n<p>我们可以使用 <code>API</code> 将在 <code>embedded</code> 模式下转换集群流控身份：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:&#x2F;&#x2F;&lt;ip&gt;:&lt;port&gt;&#x2F;setClusterMode?mode&#x3D;&lt;xxx&gt;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>mode</code> 为 <code>0</code> 代表 <code>client</code>，<code>1</code> 代表 <code>server</code>，<code>-1</code> 代表关闭。注意应用端需要引入集群限流客户端或服务端的相应依赖。</p>\n<p>在独立模式下，我们可以直接创建对应的 <code>ClusterTokenServer</code> 实例并在 <code>main</code> 函数中通过 <code>start</code> 方法启动 <code>Token Server</code>。</p>\n<h2 id=\"3-4、属性配置\"><a href=\"#3-4、属性配置\" class=\"headerlink\" title=\"3.4、属性配置\"></a>3.4、属性配置</h2><p>集群限流服务端注册动态配置源来动态地进行配置。配置类型有以下几种：</p>\n<ul>\n<li><code>namespace set</code>: 集群限流服务端服务的作用域（命名空间），可以设置为自己服务的应用名。集群限流 <code>client</code> 在连接到 <code>token server</code> 后会上报自己的命名空间（默认为 <code>project.name</code> 配置的应用名），<code>token server</code> 会根据上报的命名空间名称统计连接数。</li>\n<li><code>transport config</code>: 集群限流服务端通信相关配置，如 <code>server port</code></li>\n<li><code>flow config</code>: 集群限流服务端限流相关配置，如滑动窗口统计时长、格子数目、最大允许总 QPS等</li>\n</ul>\n<p>我们可以通过 <code>ClusterServerConfigManager</code> 的各个 <code>registerXxxProperty</code> 方法来注册相关的配置源。</p>\n<p>从 <code>1.4.1</code> 版本开始，<code>Sentinel</code> 支持给 <code>token server</code> 配置最大允许的总 <code>QPS（maxAllowedQps）</code>，来对 <code>token server</code> 的资源使用进行限制，防止在嵌入模式下影响应用本身。</p>\n<p>下图是Token Server 分配配置的示意图：</p>\n<p><img src=\"https://image.eelve.com/eblog/2021071004.png\" alt=\"Token Server分配配置\"></p>\n<h1 id=\"肆、扩展接口\"><a href=\"#肆、扩展接口\" class=\"headerlink\" title=\"肆、扩展接口\"></a>肆、扩展接口</h1><p><img src=\"https://image.eelve.com/eblog/2021071005.png\" alt=\"整体扩展架构\"></p>\n<h2 id=\"4-1、通用扩展接口\"><a href=\"#4-1、通用扩展接口\" class=\"headerlink\" title=\"4.1、通用扩展接口\"></a>4.1、通用扩展接口</h2><p>以下通用接口位于 <code>sentinel-core</code> 中：</p>\n<ul>\n<li>TokenService: 集群限流功能接口，server / client 均可复用 </li>\n<li>ClusterTokenClient: 集群限流功能客户端</li>\n<li>ClusterTokenServer: 集群限流服务端接口</li>\n<li>EmbeddedClusterTokenServer: 集群限流服务端接口（embedded 模式）</li>\n</ul>\n<p>以下通用接口位于 <code>sentinel-cluster-common-default</code>:</p>\n<ul>\n<li>EntityWriter</li>\n<li>EntityDecoder</li>\n</ul>\n<h2 id=\"4-2、Client-扩展接口\"><a href=\"#4-2、Client-扩展接口\" class=\"headerlink\" title=\"4.2、Client 扩展接口\"></a>4.2、Client 扩展接口</h2><p>集群流控 <code>Client</code> 端通信相关扩展接口：</p>\n<ul>\n<li>ClusterTransportClient：集群限流通信客户端</li>\n<li>RequestEntityWriter</li>\n<li>ResponseEntityDecoder</li>\n</ul>\n<h2 id=\"4-3、Server-扩展接口\"><a href=\"#4-3、Server-扩展接口\" class=\"headerlink\" title=\"4.3、Server 扩展接口\"></a>4.3、Server 扩展接口</h2><p>集群流控 <code>Server</code> 端通信相关扩展接口：</p>\n<ul>\n<li>ResponseEntityWriter</li>\n<li>RequestEntityDecoder</li>\n</ul>\n<p>集群流控 <code>Server</code> 端请求处理扩展接口：</p>\n<ul>\n<li>RequestProcessor: 请求处理接口 (request -&gt; response)</li>\n</ul>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践的源码</a> ,包括流量控制和初始规则加载等等。</p>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","more":"<p>【<strong>前面的话</strong>】在前面几篇文章中简单介绍了一下<code>Sentinel</code>的功能都是针对单机的，今天就来继续说一下Sentinel的集群流量控制。</p>\n<hr>\n<h1 id=\"壹、集群流控介绍\"><a href=\"#壹、集群流控介绍\" class=\"headerlink\" title=\"壹、集群流控介绍\"></a>壹、集群流控介绍</h1><h2 id=\"1-1、介绍\"><a href=\"#1-1、介绍\" class=\"headerlink\" title=\"1.1、介绍\"></a>1.1、介绍</h2><p>为什么要使用集群流控呢？假设我们希望给某个用户限制调用某个 API 的总 QPS 为 50，但机器数可能很多（比如有 100 台）。这时候我们很自然地就想到，找一个 server 来专门来统计总的调用量，其它的实例都与这台 server 通信来判断是否可以调用。这就是最基础的集群流控的方式。</p>\n<p>另外集群流控还可以解决流量不均匀导致总体限流效果不佳的问题。假设集群中有 10 台机器，我们给每台机器设置单机限流阈值为 10 QPS，理想情况下整个集群的限流阈值就为 100 QPS。不过实际情况下流量到每台机器可能会不均匀，会导致总量没有到的情况下某些机器就开始限流。因此仅靠单机维度去限制的话会无法精确地限制总体流量。而集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。</p>\n<p>集群流控中共有两种身份：</p>\n<ul>\n<li>Token Client：集群流控客户端，用于向所属 Token Server 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。</li>\n<li>Token Server：即集群流控服务端，处理来自 Token Client 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。</li>\n</ul>\n<p><img src=\"https://image.eelve.com/eblog/2021071001.png\" alt=\"结构示意图\"></p>\n<h2 id=\"1-2、模块结构\"><a href=\"#1-2、模块结构\" class=\"headerlink\" title=\"1.2、模块结构\"></a>1.2、模块结构</h2><p>Sentinel 1.4.0 开始引入了集群流控模块，主要包含以下几部分：</p>\n<ul>\n<li><code>sentinel-cluster-common-default</code>: 公共模块，包含公共接口和实体</li>\n<li><code>sentinel-cluster-client-default</code>: 默认集群流控 client 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展</li>\n<li><code>sentinel-cluster-server-default</code>: 默认集群流控 server 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展；同时提供扩展接口对接规则判断的具体实现（TokenService），默认实现是复用 sentinel-core 的相关逻辑</li>\n</ul>\n<blockquote>\n<p>注意：集群流控模块要求 JDK 版本最低为 1.7。</p>\n</blockquote>\n<h1 id=\"贰、集群流控规则\"><a href=\"#贰、集群流控规则\" class=\"headerlink\" title=\"贰、集群流控规则\"></a>贰、集群流控规则</h1><p><code>FlowRule</code>添加了两个字段用于集群限流相关配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> clusterMode; <span class=\"comment\">// 标识是否为集群限流配置</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ClusterFlowConfig clusterConfig; <span class=\"comment\">// 集群限流相关配置项</span></span><br></pre></td></tr></table></figure>\n<p>其中用一个专门的 <code>ClusterFlowConfig</code> 代表集群限流相关配置项，以与现有规则配置项分开：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局唯一的规则 ID，由集群限流管控端分配.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Long flowId;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阈值模式，默认（0）为单机均摊，1 为全局阈值.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> thresholdType = ClusterRuleConstant.FLOW_THRESHOLD_AVG_LOCAL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> strategy = ClusterRuleConstant.FLOW_CLUSTER_STRATEGY_NORMAL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 client 连接失败或通信失败时，是否退化到本地的限流模式</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> fallbackToLocalWhenFail = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>flowId</code> 代表全局唯一的规则 <code>ID</code>，<code>Sentinel</code> 集群限流服务端通过此 <code>ID</code> 来区分各个规则，因此务必保持全局唯一。一般 <code>flowId</code> 由统一的管控端进行分配，或写入至 <code>DB</code> 时生成。</li>\n<li><code>thresholdType</code> 代表集群限流阈值模式。其中单机均摊模式下配置的阈值等同于单机能够承受的限额，<code>token server</code> 会根据客户端对应的 <code>namespace</code>（默认为 <code>project.name</code> 定义的应用名）下的连接数来计算总的阈值（比如独立模式下有 3 个 client 连接到了 token server，然后配的单机均摊阈值为 10，则计算出的集群总量就为 30）；而全局模式下配置的阈值等同于整个集群的总阈值。</li>\n</ul>\n<p><code>ParamFlowRule</code> 热点参数限流相关的集群配置与 <code>FlowRule</code> 相似。</p>\n<h1 id=\"叁、集群流控配置\"><a href=\"#叁、集群流控配置\" class=\"headerlink\" title=\"叁、集群流控配置\"></a>叁、集群流控配置</h1><h2 id=\"3-1、配置方式\"><a href=\"#3-1、配置方式\" class=\"headerlink\" title=\"3.1、配置方式\"></a>3.1、配置方式</h2><blockquote>\n<p>在集群流控的场景下，推荐使用动态规则源来动态地管理规则。</p>\n</blockquote>\n<p>对于客户端，按照原有的方式来向 FlowRuleManager 和 ParamFlowRuleManager 注册动态规则源，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class=\"keyword\">new</span> NacosDataSource&lt;&gt;(remoteAddress, groupId, dataId, parser);</span><br><span class=\"line\">FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br></pre></td></tr></table></figure>\n<p>对于集群流控 <code>token server</code>，由于集群限流服务端有作用域（namespace）的概念，因此我们需要注册一个自动根据 <code>namespace</code> 生成动态规则源的 <code>PropertySupplier</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Supplier 类型：接受 namespace，返回生成的动态规则源，类型为 SentinelProperty&lt;List&lt;FlowRule&gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// ClusterFlowRuleManager 针对集群限流规则，ClusterParamFlowRuleManager 针对集群热点规则，配置方式类似</span></span><br><span class=\"line\">ClusterFlowRuleManager.setPropertySupplier(namespace -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SomeDataSource(namespace).getProperty();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然后每当集群限流服务端 <code>namespace set</code> 产生变更时，<code>Sentinel</code> 会自动针对新加入的 <code>namespace</code> 生成动态规则源并进行自动监听，并删除旧的不需要的规则源。</p>\n<h2 id=\"3-2、集群限流服务端\"><a href=\"#3-2、集群限流服务端\" class=\"headerlink\" title=\"3.2、集群限流服务端\"></a>3.2、集群限流服务端</h2><p>要想使用集群限流服务端，必须引入集群限流 server 相关依赖：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;sentinel-cluster-server-default&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.7.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3、启动方式\"><a href=\"#3-3、启动方式\" class=\"headerlink\" title=\"3.3、启动方式\"></a>3.3、启动方式</h2><p><code>Sentinel</code> 集群限流服务端有两种启动方式：</p>\n<ul>\n<li>独立模式（Alone），即作为独立的 <code>token server</code> 进程启动，独立部署，隔离性好，但是需要额外的部署操作。独立模式适合作为 <code>Global Rate Limiter</code> 给集群提供流控服务。</li>\n</ul>\n<p><img src=\"https://image.eelve.com/eblog/2021071002.png\" alt=\"独立模式\"></p>\n<ul>\n<li>嵌入模式（Embedded），即作为内置的 <code>token server</code> 与服务在同一进程中启动。在此模式下，集群中各个实例都是对等的，<code>token server</code> 和 <code>client</code> 可以随时进行转变，因此无需单独部署，灵活性比较好。但是隔离性不佳，需要限制 <code>token server</code> 的总 <code>QPS</code>，防止影响应用本身。嵌入模式适合某个应用集群内部的流控。</li>\n</ul>\n<p><img src=\"https://image.eelve.com/eblog/2021071003.png\" alt=\"嵌入模式\"></p>\n<p>我们可以使用 <code>API</code> 将在 <code>embedded</code> 模式下转换集群流控身份：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:&#x2F;&#x2F;&lt;ip&gt;:&lt;port&gt;&#x2F;setClusterMode?mode&#x3D;&lt;xxx&gt;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>mode</code> 为 <code>0</code> 代表 <code>client</code>，<code>1</code> 代表 <code>server</code>，<code>-1</code> 代表关闭。注意应用端需要引入集群限流客户端或服务端的相应依赖。</p>\n<p>在独立模式下，我们可以直接创建对应的 <code>ClusterTokenServer</code> 实例并在 <code>main</code> 函数中通过 <code>start</code> 方法启动 <code>Token Server</code>。</p>\n<h2 id=\"3-4、属性配置\"><a href=\"#3-4、属性配置\" class=\"headerlink\" title=\"3.4、属性配置\"></a>3.4、属性配置</h2><p>集群限流服务端注册动态配置源来动态地进行配置。配置类型有以下几种：</p>\n<ul>\n<li><code>namespace set</code>: 集群限流服务端服务的作用域（命名空间），可以设置为自己服务的应用名。集群限流 <code>client</code> 在连接到 <code>token server</code> 后会上报自己的命名空间（默认为 <code>project.name</code> 配置的应用名），<code>token server</code> 会根据上报的命名空间名称统计连接数。</li>\n<li><code>transport config</code>: 集群限流服务端通信相关配置，如 <code>server port</code></li>\n<li><code>flow config</code>: 集群限流服务端限流相关配置，如滑动窗口统计时长、格子数目、最大允许总 QPS等</li>\n</ul>\n<p>我们可以通过 <code>ClusterServerConfigManager</code> 的各个 <code>registerXxxProperty</code> 方法来注册相关的配置源。</p>\n<p>从 <code>1.4.1</code> 版本开始，<code>Sentinel</code> 支持给 <code>token server</code> 配置最大允许的总 <code>QPS（maxAllowedQps）</code>，来对 <code>token server</code> 的资源使用进行限制，防止在嵌入模式下影响应用本身。</p>\n<p>下图是Token Server 分配配置的示意图：</p>\n<p><img src=\"https://image.eelve.com/eblog/2021071004.png\" alt=\"Token Server分配配置\"></p>\n<h1 id=\"肆、扩展接口\"><a href=\"#肆、扩展接口\" class=\"headerlink\" title=\"肆、扩展接口\"></a>肆、扩展接口</h1><p><img src=\"https://image.eelve.com/eblog/2021071005.png\" alt=\"整体扩展架构\"></p>\n<h2 id=\"4-1、通用扩展接口\"><a href=\"#4-1、通用扩展接口\" class=\"headerlink\" title=\"4.1、通用扩展接口\"></a>4.1、通用扩展接口</h2><p>以下通用接口位于 <code>sentinel-core</code> 中：</p>\n<ul>\n<li>TokenService: 集群限流功能接口，server / client 均可复用 </li>\n<li>ClusterTokenClient: 集群限流功能客户端</li>\n<li>ClusterTokenServer: 集群限流服务端接口</li>\n<li>EmbeddedClusterTokenServer: 集群限流服务端接口（embedded 模式）</li>\n</ul>\n<p>以下通用接口位于 <code>sentinel-cluster-common-default</code>:</p>\n<ul>\n<li>EntityWriter</li>\n<li>EntityDecoder</li>\n</ul>\n<h2 id=\"4-2、Client-扩展接口\"><a href=\"#4-2、Client-扩展接口\" class=\"headerlink\" title=\"4.2、Client 扩展接口\"></a>4.2、Client 扩展接口</h2><p>集群流控 <code>Client</code> 端通信相关扩展接口：</p>\n<ul>\n<li>ClusterTransportClient：集群限流通信客户端</li>\n<li>RequestEntityWriter</li>\n<li>ResponseEntityDecoder</li>\n</ul>\n<h2 id=\"4-3、Server-扩展接口\"><a href=\"#4-3、Server-扩展接口\" class=\"headerlink\" title=\"4.3、Server 扩展接口\"></a>4.3、Server 扩展接口</h2><p>集群流控 <code>Server</code> 端通信相关扩展接口：</p>\n<ul>\n<li>ResponseEntityWriter</li>\n<li>RequestEntityDecoder</li>\n</ul>\n<p>集群流控 <code>Server</code> 端请求处理扩展接口：</p>\n<ul>\n<li>RequestProcessor: 请求处理接口 (request -&gt; response)</li>\n</ul>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践的源码</a> ,包括流量控制和初始规则加载等等。</p>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","categories":[{"name":"sentinel","path":"api/categories/sentinel.json"}],"tags":[{"name":"sentinel","path":"api/tags/sentinel.json"}]}
{"total":77,"pageSize":10,"pageCount":8,"data":[{"title":"Sentinel进阶之来源访问控制","slug":"Sentinel进阶之来源访问控制","date":"2021-10-03T04:08:36.000Z","updated":"2021-10-03T04:35:43.971Z","comments":true,"path":"api/articles/Sentinel进阶之来源访问控制.json","excerpt":null,"keywords":"南国薏米","cover":"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png","content":"<p>【<strong>前面的话</strong>】在前面几篇文章中简单介绍了一下<code>Sentinel</code>的功能都是针对所有的请求资源，今天就来继续说一下<code>Sentinel</code>的来源访问控制。</p>\n<hr>\n<h1 id=\"壹、概述\"><a href=\"#壹、概述\" class=\"headerlink\" title=\"壹、概述\"></a>壹、概述</h1><p>很多时候，我们需要根据调用方来限制资源是否通过，这时候可以使用 <code>Sentinel</code> 的黑白名单控制的功能。黑白名单根据资源的请求来源（<code>origin</code>）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。</p>\n<blockquote>\n<p>调用方信息通过 <code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数传入。</p>\n</blockquote>\n<h1 id=\"贰、规则配置\"><a href=\"#贰、规则配置\" class=\"headerlink\" title=\"贰、规则配置\"></a>贰、规则配置</h1><p>黑白名单规则（<code>AuthorityRule</code>）非常简单，主要有以下配置项：</p>\n<ul>\n<li><code>resource</code>：资源名，即限流规则的作用对象</li>\n<li><code>limitApp</code>：对应的黑名单/白名单，不同 <code>origin</code> 用 , 分隔，如 <code>appA</code>,<code>appB</code></li>\n<li><code>strategy</code>：限制模式，<code>AUTHORITY_WHITE</code> 为白名单模式，<code>AUTHORITY_BLACK</code> 为黑名单模式，默认为白名单模式</li>\n</ul>\n<h1 id=\"叁、示例\"><a href=\"#叁、示例\" class=\"headerlink\" title=\"叁、示例\"></a>叁、示例</h1><p>比如我们希望控制对资源 <code>test</code> 的访问设置白名单，只有来源为 <code>appA</code> 和 <code>appB</code> 的请求才可通过，则可以配置如下白名单规则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthorityDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String RESOURCE_NAME = <span class=\"string\">&quot;testABC&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;========Testing for black list========&quot;</span>);</span><br><span class=\"line\">        initBlackRules();</span><br><span class=\"line\">        testFor(RESOURCE_NAME, <span class=\"string\">&quot;appA&quot;</span>);</span><br><span class=\"line\">        testFor(RESOURCE_NAME, <span class=\"string\">&quot;appB&quot;</span>);</span><br><span class=\"line\">        testFor(RESOURCE_NAME, <span class=\"string\">&quot;appC&quot;</span>);</span><br><span class=\"line\">        testFor(RESOURCE_NAME, <span class=\"string\">&quot;appE&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;========Testing for white list========&quot;</span>);</span><br><span class=\"line\">        initWhiteRules();</span><br><span class=\"line\">        testFor(RESOURCE_NAME, <span class=\"string\">&quot;appA&quot;</span>);</span><br><span class=\"line\">        testFor(RESOURCE_NAME, <span class=\"string\">&quot;appB&quot;</span>);</span><br><span class=\"line\">        testFor(RESOURCE_NAME, <span class=\"string\">&quot;appC&quot;</span>);</span><br><span class=\"line\">        testFor(RESOURCE_NAME, <span class=\"string\">&quot;appE&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testFor</span><span class=\"params\">(<span class=\"comment\">/*@NonNull*/</span> String resource, <span class=\"comment\">/*@NonNull*/</span> String origin)</span> </span>&#123;</span><br><span class=\"line\">        ContextUtil.enter(resource, origin);</span><br><span class=\"line\">        Entry entry = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            entry = SphU.entry(resource);</span><br><span class=\"line\">            System.out.println(String.format(<span class=\"string\">&quot;Passed for resource %s, origin is %s&quot;</span>, resource, origin));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BlockException ex) &#123;</span><br><span class=\"line\">            System.err.println(String.format(<span class=\"string\">&quot;Blocked for resource %s, origin is %s&quot;</span>, resource, origin));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entry != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                entry.exit();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ContextUtil.exit();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">initWhiteRules</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        AuthorityRule rule = <span class=\"keyword\">new</span> AuthorityRule();</span><br><span class=\"line\">        rule.setResource(RESOURCE_NAME);</span><br><span class=\"line\">        rule.setStrategy(RuleConstant.AUTHORITY_WHITE);</span><br><span class=\"line\">        rule.setLimitApp(<span class=\"string\">&quot;appA,appE&quot;</span>);</span><br><span class=\"line\">        AuthorityRuleManager.loadRules(Collections.singletonList(rule));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">initBlackRules</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        AuthorityRule rule = <span class=\"keyword\">new</span> AuthorityRule();</span><br><span class=\"line\">        rule.setResource(RESOURCE_NAME);</span><br><span class=\"line\">        rule.setStrategy(RuleConstant.AUTHORITY_BLACK);</span><br><span class=\"line\">        rule.setLimitApp(<span class=\"string\">&quot;appA,appB&quot;</span>);</span><br><span class=\"line\">        AuthorityRuleManager.loadRules(Collections.singletonList(rule));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"肆、SpringBoot中的使用\"><a href=\"#肆、SpringBoot中的使用\" class=\"headerlink\" title=\"肆、SpringBoot中的使用\"></a>肆、SpringBoot中的使用</h1><h2 id=\"4-1、限制来源token\"><a href=\"#4-1、限制来源token\" class=\"headerlink\" title=\"4.1、限制来源token\"></a>4.1、限制来源token</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configurable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SentinelRequestParserConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RequestOriginParser <span class=\"title\">requestOriginParser</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (httpServletRequest -&gt; httpServletRequest.getHeader(<span class=\"string\">&quot;token&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-1、限制来源请求地址\"><a href=\"#4-1、限制来源请求地址\" class=\"headerlink\" title=\"4.1、限制来源请求地址\"></a>4.1、限制来源请求地址</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configurable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SentinelRequestParserConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RequestOriginParser <span class=\"title\">requestOriginParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (httpServletRequest -&gt; httpServletRequest.getRemoteAddr());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践自定义调用链的源码</a> 。</p>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","raw":null,"categories":[{"name":"sentinel","path":"api/categories/sentinel.json"}],"tags":[{"name":"sentinel","path":"api/tags/sentinel.json"}]},{"title":"Sentinel进阶之热点参数限流","slug":"Sentinel进阶之热点参数限流","date":"2021-08-30T14:04:09.000Z","updated":"2021-08-30T14:23:28.942Z","comments":true,"path":"api/articles/Sentinel进阶之热点参数限流.json","excerpt":null,"keywords":"南国薏米","cover":"https://image.eelve.com/eblog/2021083001.png","content":"<p>【<strong>前面的话</strong>】在前面几篇文章中简单介绍了一下<code>Sentinel</code>的功能都是针对接口的，今天就来继续说一下Sentinel的热点参数限流。</p>\n<hr>\n<h1 id=\"壹、概览\"><a href=\"#壹、概览\" class=\"headerlink\" title=\"壹、概览\"></a>壹、概览</h1><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 <code>Top K</code> 数据，并对其访问进行限制。比如：</p>\n<ul>\n<li>商品 <code>ID</code> 为参数，统计一段时间内最常购买的商品 <code>ID</code> 并进行限制</li>\n<li>用户 <code>ID</code> 为参数，针对一段时间内频繁访问的用户 <code>ID</code> 进行限制</li>\n</ul>\n<p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p>\n<p><img src=\"https://image.eelve.com/eblog/2021083001.png\" alt=\"sentinel-hot-param-overview\"></p>\n<p><code>Sentinel</code> 利用 <code>LRU</code> 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。</p>\n<h1 id=\"贰、基本使用\"><a href=\"#贰、基本使用\" class=\"headerlink\" title=\"贰、基本使用\"></a>贰、基本使用</h1><p>要使用热点参数限流功能，需要引入以下依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;sentinel-parameter-flow-control&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;x.y.z&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>然后为对应的资源配置热点参数限流规则，并在 <code>entry</code> 的时候传入相应的参数，即可使热点参数限流生效。</p>\n<blockquote>\n<p>注：若自行扩展并注册了自己实现的 <code>SlotChainBuilder</code>，并希望使用热点参数限流功能，则可以在 <code>chain</code> 里面合适的地方插入 <code>ParamFlowSlot</code>。</p>\n</blockquote>\n<p>那么如何传入对应的参数以便 <code>Sentinel</code> 统计呢？我们可以通过 <code>SphU</code> 类里面几个 <code>entry</code> 重载方法来传入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Entry <span class=\"title\">entry</span><span class=\"params\">(String name, EntryType type, <span class=\"keyword\">int</span> count, Object... args)</span> <span class=\"keyword\">throws</span> BlockException</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Entry <span class=\"title\">entry</span><span class=\"params\">(Method method, EntryType type, <span class=\"keyword\">int</span> count, Object... args)</span> <span class=\"keyword\">throws</span> BlockException</span></span><br></pre></td></tr></table></figure>\n<p>其中最后的一串 <code>args</code> 就是要传入的参数，有多个就按照次序依次传入。比如要传入两个参数 <code>paramA</code> 和 <code>paramB</code>，则可以：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// paramA in index 0, paramB in index 1.</span></span><br><span class=\"line\"><span class=\"comment\">// 若需要配置例外项或者使用集群维度流控，则传入的参数只支持基本类型。</span></span><br><span class=\"line\">SphU.entry(resourceName, EntryType.IN, <span class=\"number\">1</span>, paramA, paramB);</span><br></pre></td></tr></table></figure>\n<p><code>注意</code>：若 <code>entry</code> 的时候传入了热点参数，那么 <code>exit</code> 的时候也一定要带上对应的参数（<code>exit(count, args)</code>），否则可能会有统计错误。正确的示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Entry entry = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    entry = SphU.entry(resourceName, EntryType.IN, <span class=\"number\">1</span>, paramA, paramB);</span><br><span class=\"line\">    <span class=\"comment\">// Your logic here.</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (BlockException ex) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Handle request rejection.</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        entry.exit(<span class=\"number\">1</span>, paramA, paramB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于 <code>@SentinelResource</code> 注解方式定义的资源，若注解作用的方法上有参数，<code>Sentinel</code> 会将它们作为参数传入 <code>SphU.entry(res, args)</code>。比如以下的方法里面 <code>uid</code> 和 <code>type</code> 会分别作为第一个和第二个参数传入 <code>Sentinel API</code>，从而可以用于热点规则判断：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SentinelResource(&quot;myMethod&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doSomething</span><span class=\"params\">(String uid, <span class=\"keyword\">int</span> type)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// some logic here...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"叁、热点参数规则\"><a href=\"#叁、热点参数规则\" class=\"headerlink\" title=\"叁、热点参数规则\"></a>叁、热点参数规则</h1><p>热点参数规则（<code>ParamFlowRule</code>）类似于流量控制规则（<code>FlowRule</code>）：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>resource</td>\n<td>资源名，必填</td>\n<td></td>\n</tr>\n<tr>\n<td>count</td>\n<td>限流阈值，必填</td>\n<td></td>\n</tr>\n<tr>\n<td>grade</td>\n<td>限流模式</td>\n<td>QPS 模式</td>\n</tr>\n<tr>\n<td>durationInSec</td>\n<td>统计窗口时间长度（单位为秒），1.6.0 版本开始支持</td>\n<td>1s</td>\n</tr>\n<tr>\n<td>controlBehavior</td>\n<td>流控效果（支持快速失败和匀速排队模式），1.6.0 版本开始支持</td>\n<td>快速失败</td>\n</tr>\n<tr>\n<td>maxQueueingTimeMs</td>\n<td>最大排队等待时长（仅在匀速排队模式生效），1.6.0 版本开始支持</td>\n<td>0ms</td>\n</tr>\n<tr>\n<td>paramIdx</td>\n<td>热点参数的索引，必填，对应 SphU.entry(xxx, args) 中的参数索引位置</td>\n<td></td>\n</tr>\n<tr>\n<td>paramFlowItemList</td>\n<td>参数例外项，可以针对指定的参数值单独设置限流阈值，不受前面 count 阈值的限制。仅支持基本类型和字符串类型</td>\n<td></td>\n</tr>\n<tr>\n<td>clusterMode</td>\n<td>是否是集群参数流控规则</td>\n<td>false</td>\n</tr>\n<tr>\n<td>clusterConfig</td>\n<td>集群流控相关配置</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>我们可以通过 <code>ParamFlowRuleManager</code> 的 <code>loadRules</code> 方法更新热点参数规则，下面是一个示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ParamFlowRule rule = <span class=\"keyword\">new</span> ParamFlowRule(resourceName)</span><br><span class=\"line\">    .setParamIdx(<span class=\"number\">0</span>)</span><br><span class=\"line\">    .setCount(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 针对 int 类型的参数 PARAM_B，单独设置限流 QPS 阈值为 10，而不是全局的阈值 5.</span></span><br><span class=\"line\">ParamFlowItem item = <span class=\"keyword\">new</span> ParamFlowItem().setObject(String.valueOf(PARAM_B))</span><br><span class=\"line\">    .setClassType(<span class=\"keyword\">int</span>.class.getName())</span><br><span class=\"line\">    .setCount(<span class=\"number\">10</span>);</span><br><span class=\"line\">rule.setParamFlowItemList(Collections.singletonList(item));</span><br><span class=\"line\"></span><br><span class=\"line\">ParamFlowRuleManager.loadRules(Collections.singletonList(rule));</span><br></pre></td></tr></table></figure>\n<h1 id=\"肆、示例\"><a href=\"#肆、示例\" class=\"headerlink\" title=\"肆、示例\"></a>肆、示例</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParamFlowQpsDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PARAM_A = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PARAM_B = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PARAM_C = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PARAM_D = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Here we prepare different parameters to validate flow control by parameters.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer[] PARAMS = <span class=\"keyword\">new</span> Integer[] &#123;PARAM_A, PARAM_B, PARAM_C, PARAM_D&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String RESOURCE_KEY = <span class=\"string\">&quot;resA&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        initParamFlowRules();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">20</span>;</span><br><span class=\"line\">        ParamFlowQpsRunner&lt;Integer&gt; runner = <span class=\"keyword\">new</span> ParamFlowQpsRunner&lt;&gt;(PARAMS, RESOURCE_KEY, threadCount, <span class=\"number\">120</span>);</span><br><span class=\"line\">        runner.tick();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        runner.simulateTraffic();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">initParamFlowRules</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// QPS mode, threshold is 5 for every frequent &quot;hot spot&quot; parameter in index 0 (the first arg).</span></span><br><span class=\"line\">        ParamFlowRule rule = <span class=\"keyword\">new</span> ParamFlowRule(RESOURCE_KEY)</span><br><span class=\"line\">            .setParamIdx(<span class=\"number\">0</span>)</span><br><span class=\"line\">            .setGrade(RuleConstant.FLOW_GRADE_QPS)</span><br><span class=\"line\">            <span class=\"comment\">//.setDurationInSec(3)</span></span><br><span class=\"line\">            <span class=\"comment\">//.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER)</span></span><br><span class=\"line\">            <span class=\"comment\">//.setMaxQueueingTimeMs(600)</span></span><br><span class=\"line\">            .setCount(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can set threshold count for specific parameter value individually.</span></span><br><span class=\"line\">        <span class=\"comment\">// Here we add an exception item. That means: QPS threshold of entries with parameter `PARAM_B` (type: int)</span></span><br><span class=\"line\">        <span class=\"comment\">// in index 0 will be 10, rather than the global threshold (5).</span></span><br><span class=\"line\">        ParamFlowItem item = <span class=\"keyword\">new</span> ParamFlowItem().setObject(String.valueOf(PARAM_B))</span><br><span class=\"line\">            .setClassType(<span class=\"keyword\">int</span>.class.getName())</span><br><span class=\"line\">            .setCount(<span class=\"number\">10</span>);</span><br><span class=\"line\">        rule.setParamFlowItemList(Collections.singletonList(item));</span><br><span class=\"line\">        ParamFlowRuleManager.loadRules(Collections.singletonList(rule));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践的源码</a> ,包括流量控制和初始规则加载等等。</p>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","raw":null,"categories":[{"name":"sentinel","path":"api/categories/sentinel.json"}],"tags":[{"name":"sentinel","path":"api/tags/sentinel.json"}]},{"title":"Sentinel进阶之集群流量控制","slug":"Sentinel进阶之集群流量控制","date":"2021-07-10T01:04:09.000Z","updated":"2021-07-19T02:33:46.616Z","comments":true,"path":"api/articles/Sentinel进阶之集群流量控制.json","excerpt":null,"keywords":"南国薏米","cover":"https://image.eelve.com/eblog/2021071001.png","content":"<p>【<strong>前面的话</strong>】在前面几篇文章中简单介绍了一下<code>Sentinel</code>的功能都是针对单机的，今天就来继续说一下Sentinel的集群流量控制。</p>\n<hr>\n<h1 id=\"壹、集群流控介绍\"><a href=\"#壹、集群流控介绍\" class=\"headerlink\" title=\"壹、集群流控介绍\"></a>壹、集群流控介绍</h1><h2 id=\"1-1、介绍\"><a href=\"#1-1、介绍\" class=\"headerlink\" title=\"1.1、介绍\"></a>1.1、介绍</h2><p>为什么要使用集群流控呢？假设我们希望给某个用户限制调用某个 API 的总 QPS 为 50，但机器数可能很多（比如有 100 台）。这时候我们很自然地就想到，找一个 server 来专门来统计总的调用量，其它的实例都与这台 server 通信来判断是否可以调用。这就是最基础的集群流控的方式。</p>\n<p>另外集群流控还可以解决流量不均匀导致总体限流效果不佳的问题。假设集群中有 10 台机器，我们给每台机器设置单机限流阈值为 10 QPS，理想情况下整个集群的限流阈值就为 100 QPS。不过实际情况下流量到每台机器可能会不均匀，会导致总量没有到的情况下某些机器就开始限流。因此仅靠单机维度去限制的话会无法精确地限制总体流量。而集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。</p>\n<p>集群流控中共有两种身份：</p>\n<ul>\n<li>Token Client：集群流控客户端，用于向所属 Token Server 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。</li>\n<li>Token Server：即集群流控服务端，处理来自 Token Client 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。</li>\n</ul>\n<p><img src=\"https://image.eelve.com/eblog/2021071001.png\" alt=\"结构示意图\"></p>\n<h2 id=\"1-2、模块结构\"><a href=\"#1-2、模块结构\" class=\"headerlink\" title=\"1.2、模块结构\"></a>1.2、模块结构</h2><p>Sentinel 1.4.0 开始引入了集群流控模块，主要包含以下几部分：</p>\n<ul>\n<li><code>sentinel-cluster-common-default</code>: 公共模块，包含公共接口和实体</li>\n<li><code>sentinel-cluster-client-default</code>: 默认集群流控 client 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展</li>\n<li><code>sentinel-cluster-server-default</code>: 默认集群流控 server 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展；同时提供扩展接口对接规则判断的具体实现（TokenService），默认实现是复用 sentinel-core 的相关逻辑</li>\n</ul>\n<blockquote>\n<p>注意：集群流控模块要求 JDK 版本最低为 1.7。</p>\n</blockquote>\n<h1 id=\"贰、集群流控规则\"><a href=\"#贰、集群流控规则\" class=\"headerlink\" title=\"贰、集群流控规则\"></a>贰、集群流控规则</h1><p><code>FlowRule</code>添加了两个字段用于集群限流相关配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> clusterMode; <span class=\"comment\">// 标识是否为集群限流配置</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ClusterFlowConfig clusterConfig; <span class=\"comment\">// 集群限流相关配置项</span></span><br></pre></td></tr></table></figure>\n<p>其中用一个专门的 <code>ClusterFlowConfig</code> 代表集群限流相关配置项，以与现有规则配置项分开：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局唯一的规则 ID，由集群限流管控端分配.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Long flowId;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阈值模式，默认（0）为单机均摊，1 为全局阈值.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> thresholdType = ClusterRuleConstant.FLOW_THRESHOLD_AVG_LOCAL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> strategy = ClusterRuleConstant.FLOW_CLUSTER_STRATEGY_NORMAL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 client 连接失败或通信失败时，是否退化到本地的限流模式</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> fallbackToLocalWhenFail = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>flowId</code> 代表全局唯一的规则 <code>ID</code>，<code>Sentinel</code> 集群限流服务端通过此 <code>ID</code> 来区分各个规则，因此务必保持全局唯一。一般 <code>flowId</code> 由统一的管控端进行分配，或写入至 <code>DB</code> 时生成。</li>\n<li><code>thresholdType</code> 代表集群限流阈值模式。其中单机均摊模式下配置的阈值等同于单机能够承受的限额，<code>token server</code> 会根据客户端对应的 <code>namespace</code>（默认为 <code>project.name</code> 定义的应用名）下的连接数来计算总的阈值（比如独立模式下有 3 个 client 连接到了 token server，然后配的单机均摊阈值为 10，则计算出的集群总量就为 30）；而全局模式下配置的阈值等同于整个集群的总阈值。</li>\n</ul>\n<p><code>ParamFlowRule</code> 热点参数限流相关的集群配置与 <code>FlowRule</code> 相似。</p>\n<h1 id=\"叁、集群流控配置\"><a href=\"#叁、集群流控配置\" class=\"headerlink\" title=\"叁、集群流控配置\"></a>叁、集群流控配置</h1><h2 id=\"3-1、配置方式\"><a href=\"#3-1、配置方式\" class=\"headerlink\" title=\"3.1、配置方式\"></a>3.1、配置方式</h2><blockquote>\n<p>在集群流控的场景下，推荐使用动态规则源来动态地管理规则。</p>\n</blockquote>\n<p>对于客户端，按照原有的方式来向 FlowRuleManager 和 ParamFlowRuleManager 注册动态规则源，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class=\"keyword\">new</span> NacosDataSource&lt;&gt;(remoteAddress, groupId, dataId, parser);</span><br><span class=\"line\">FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br></pre></td></tr></table></figure>\n<p>对于集群流控 <code>token server</code>，由于集群限流服务端有作用域（namespace）的概念，因此我们需要注册一个自动根据 <code>namespace</code> 生成动态规则源的 <code>PropertySupplier</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Supplier 类型：接受 namespace，返回生成的动态规则源，类型为 SentinelProperty&lt;List&lt;FlowRule&gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// ClusterFlowRuleManager 针对集群限流规则，ClusterParamFlowRuleManager 针对集群热点规则，配置方式类似</span></span><br><span class=\"line\">ClusterFlowRuleManager.setPropertySupplier(namespace -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SomeDataSource(namespace).getProperty();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然后每当集群限流服务端 <code>namespace set</code> 产生变更时，<code>Sentinel</code> 会自动针对新加入的 <code>namespace</code> 生成动态规则源并进行自动监听，并删除旧的不需要的规则源。</p>\n<h2 id=\"3-2、集群限流服务端\"><a href=\"#3-2、集群限流服务端\" class=\"headerlink\" title=\"3.2、集群限流服务端\"></a>3.2、集群限流服务端</h2><p>要想使用集群限流服务端，必须引入集群限流 server 相关依赖：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;sentinel-cluster-server-default&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.7.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3、启动方式\"><a href=\"#3-3、启动方式\" class=\"headerlink\" title=\"3.3、启动方式\"></a>3.3、启动方式</h2><p><code>Sentinel</code> 集群限流服务端有两种启动方式：</p>\n<ul>\n<li>独立模式（Alone），即作为独立的 <code>token server</code> 进程启动，独立部署，隔离性好，但是需要额外的部署操作。独立模式适合作为 <code>Global Rate Limiter</code> 给集群提供流控服务。</li>\n</ul>\n<p><img src=\"https://image.eelve.com/eblog/2021071002.png\" alt=\"独立模式\"></p>\n<ul>\n<li>嵌入模式（Embedded），即作为内置的 <code>token server</code> 与服务在同一进程中启动。在此模式下，集群中各个实例都是对等的，<code>token server</code> 和 <code>client</code> 可以随时进行转变，因此无需单独部署，灵活性比较好。但是隔离性不佳，需要限制 <code>token server</code> 的总 <code>QPS</code>，防止影响应用本身。嵌入模式适合某个应用集群内部的流控。</li>\n</ul>\n<p><img src=\"https://image.eelve.com/eblog/2021071003.png\" alt=\"嵌入模式\"></p>\n<p>我们可以使用 <code>API</code> 将在 <code>embedded</code> 模式下转换集群流控身份：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:&#x2F;&#x2F;&lt;ip&gt;:&lt;port&gt;&#x2F;setClusterMode?mode&#x3D;&lt;xxx&gt;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>mode</code> 为 <code>0</code> 代表 <code>client</code>，<code>1</code> 代表 <code>server</code>，<code>-1</code> 代表关闭。注意应用端需要引入集群限流客户端或服务端的相应依赖。</p>\n<p>在独立模式下，我们可以直接创建对应的 <code>ClusterTokenServer</code> 实例并在 <code>main</code> 函数中通过 <code>start</code> 方法启动 <code>Token Server</code>。</p>\n<h2 id=\"3-4、属性配置\"><a href=\"#3-4、属性配置\" class=\"headerlink\" title=\"3.4、属性配置\"></a>3.4、属性配置</h2><p>集群限流服务端注册动态配置源来动态地进行配置。配置类型有以下几种：</p>\n<ul>\n<li><code>namespace set</code>: 集群限流服务端服务的作用域（命名空间），可以设置为自己服务的应用名。集群限流 <code>client</code> 在连接到 <code>token server</code> 后会上报自己的命名空间（默认为 <code>project.name</code> 配置的应用名），<code>token server</code> 会根据上报的命名空间名称统计连接数。</li>\n<li><code>transport config</code>: 集群限流服务端通信相关配置，如 <code>server port</code></li>\n<li><code>flow config</code>: 集群限流服务端限流相关配置，如滑动窗口统计时长、格子数目、最大允许总 QPS等</li>\n</ul>\n<p>我们可以通过 <code>ClusterServerConfigManager</code> 的各个 <code>registerXxxProperty</code> 方法来注册相关的配置源。</p>\n<p>从 <code>1.4.1</code> 版本开始，<code>Sentinel</code> 支持给 <code>token server</code> 配置最大允许的总 <code>QPS（maxAllowedQps）</code>，来对 <code>token server</code> 的资源使用进行限制，防止在嵌入模式下影响应用本身。</p>\n<p>下图是Token Server 分配配置的示意图：</p>\n<p><img src=\"https://image.eelve.com/eblog/2021071004.png\" alt=\"Token Server分配配置\"></p>\n<h1 id=\"肆、扩展接口\"><a href=\"#肆、扩展接口\" class=\"headerlink\" title=\"肆、扩展接口\"></a>肆、扩展接口</h1><p><img src=\"https://image.eelve.com/eblog/2021071005.png\" alt=\"整体扩展架构\"></p>\n<h2 id=\"4-1、通用扩展接口\"><a href=\"#4-1、通用扩展接口\" class=\"headerlink\" title=\"4.1、通用扩展接口\"></a>4.1、通用扩展接口</h2><p>以下通用接口位于 <code>sentinel-core</code> 中：</p>\n<ul>\n<li>TokenService: 集群限流功能接口，server / client 均可复用 </li>\n<li>ClusterTokenClient: 集群限流功能客户端</li>\n<li>ClusterTokenServer: 集群限流服务端接口</li>\n<li>EmbeddedClusterTokenServer: 集群限流服务端接口（embedded 模式）</li>\n</ul>\n<p>以下通用接口位于 <code>sentinel-cluster-common-default</code>:</p>\n<ul>\n<li>EntityWriter</li>\n<li>EntityDecoder</li>\n</ul>\n<h2 id=\"4-2、Client-扩展接口\"><a href=\"#4-2、Client-扩展接口\" class=\"headerlink\" title=\"4.2、Client 扩展接口\"></a>4.2、Client 扩展接口</h2><p>集群流控 <code>Client</code> 端通信相关扩展接口：</p>\n<ul>\n<li>ClusterTransportClient：集群限流通信客户端</li>\n<li>RequestEntityWriter</li>\n<li>ResponseEntityDecoder</li>\n</ul>\n<h2 id=\"4-3、Server-扩展接口\"><a href=\"#4-3、Server-扩展接口\" class=\"headerlink\" title=\"4.3、Server 扩展接口\"></a>4.3、Server 扩展接口</h2><p>集群流控 <code>Server</code> 端通信相关扩展接口：</p>\n<ul>\n<li>ResponseEntityWriter</li>\n<li>RequestEntityDecoder</li>\n</ul>\n<p>集群流控 <code>Server</code> 端请求处理扩展接口：</p>\n<ul>\n<li>RequestProcessor: 请求处理接口 (request -&gt; response)</li>\n</ul>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践的源码</a> ,包括流量控制和初始规则加载等等。</p>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","raw":null,"categories":[{"name":"sentinel","path":"api/categories/sentinel.json"}],"tags":[{"name":"sentinel","path":"api/tags/sentinel.json"}]},{"title":"Sentinel进阶之系统自适应保护","slug":"Sentinel进阶之系统自适应保护","date":"2021-06-07T00:07:07.000Z","updated":"2021-06-07T00:30:39.658Z","comments":true,"path":"api/articles/Sentinel进阶之系统自适应保护.json","excerpt":null,"keywords":"南国薏米","cover":"https://image.eelve.com/eblog/system-load.png","content":"<p>【<strong>前面的话</strong>】在前文 <a href=\"https://eelve.com/archives/sentinel-circuit-breaking\">Sentinel进阶之熔断降级</a> 中简单介绍了一下<code>Sentinel</code>的流量控制，今天就来继续说一下Sentinel的系统自适应保护。</p>\n<hr>\n<h1 id=\"壹、概述\"><a href=\"#壹、概述\" class=\"headerlink\" title=\"壹、概述\"></a>壹、概述</h1><p>Sentinel 系统自适应保护从整体维度对应用入口流量进行控制，结合应用的 Load、总体平均 RT、入口QPS 和线程数等几个维度的监控指标，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>\n<h1 id=\"贰、背景\"><a href=\"#贰、背景\" class=\"headerlink\" title=\"贰、背景\"></a>贰、背景</h1><p>在开始之前，先回顾一下 <code>Sentinel</code> 做系统自适应保护的目的：</p>\n<ul>\n<li>保证系统不被拖垮</li>\n<li>在系统稳定的前提下，保持系统的吞吐量</li>\n</ul>\n<p>长期以来，系统自适应保护的思路是根据硬指标，即系统的负载 (load1) 来做系统过载保护。当系统负载高于某个阈值，就禁止或者减少流量的进入；当load开始好转，则恢复流量的进入。这个思路给我们带来了不可避免的两个问题：</p>\n<ul>\n<li>load 是一个“果”，如果根据 load 的情况来调节流量的通过率，那么就始终有延迟性。也就意味着通过率的任何调整，都会过一段时间才能看到效果。当前通过率是使load恶化的一个动作，那么也至少要过 1 秒之后才能观测到；同理，如果当前通过率调整是让 <code>load</code> 好转的一个动作，也需要1秒之后才能继续调整，这样就浪费了系统的处理能力。所以我们看到的曲线，总是会有抖动。</li>\n<li>恢复慢。想象一下这样的一个场景（真实），出现了这样一个问题，下游应用不可靠，导致应用RT很高，从而load到了一个很高的点。过了一段时间之后下游应用恢复了，应用RT也相应减少。这个时候，其实应该大幅度增大流量的通过率；但是由于这个时候 <code>load</code> 仍然很高，通过率的恢复仍然不高。</li>\n</ul>\n<p><code>TCP BBR</code> 的思想给了我们一个很大的启发。我们应该根据系统能够处理的请求，和允许进来的请求，来做平衡，而不是根据一个间接的指标（系统 load）来做限流。最终我们追求的目标是 <code>在系统不被拖垮的情况下，提高系统的吞吐率，而不是 load 一定要到低于某个阈值</code>。如果我们还是按照固有的思维，超过特定的 load 就禁止流量进入，系统 load 恢复就放开流量，这样做的结果是无论我们怎么调参数，调比例，都是按照果来调节因，都无法取得良好的效果。</p>\n<p><code>Sentinel</code> 在系统自适应保护的做法是，用 load1 作为启动控制流量的值，而允许通过的流量由处理请求的能力，即请求的响应时间以及当前系统正在处理的请求速率来决定。</p>\n<h1 id=\"叁、系统规则\"><a href=\"#叁、系统规则\" class=\"headerlink\" title=\"叁、系统规则\"></a>叁、系统规则</h1><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的总体Load、RT、入口QPS 和线程数四个维度监控应用数据，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>\n<p>系统保护规则是应用整体维度的，而不是资源维度的，并且<code>仅对入口流量生效</code>。入口流量指的是进入应用的流量（<code>EntryType.IN</code>），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p>\n<p>系统规则支持以下的阈值类型：</p>\n<ul>\n<li><code>Load</code>（仅对 <code>Linux/Unix-like</code> 机器生效）：当系统 <code>load1</code> 超过阈值，且系统当前的并发线程数超过系统容量时才会触发系统保护。系统容量由系统的 <code>maxQps * minRt</code> 计算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li>\n<li><code>CPU usage</code>（1.5.0+ 版本）：当系统 <code>CPU</code> 使用率超过阈值即触发系统保护（取值范围 <code>0.0-1.0</code>）。</li>\n<li><code>RT</code>：当单台机器上所有入口流量的<code>平均RT</code> 达到阈值即触发系统保护，单位是毫秒。</li>\n<li><code>线程数</code>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>\n<li><code>入口 QPS</code>：当单台机器上所有入口流量的 <code>QPS</code> 达到阈值即触发系统保护。</li>\n</ul>\n<h1 id=\"肆、原理\"><a href=\"#肆、原理\" class=\"headerlink\" title=\"肆、原理\"></a>肆、原理</h1><p>先用经典图来镇楼:</p>\n<p><img src=\"https://image.eelve.com/eblog/system-load.png\" alt=\"系统load\"></p>\n<p>我们把系统处理请求的过程想象为一个水管，到来的请求是往这个水管灌水，当系统处理顺畅的时候，请求不需要排队，直接从水管中穿过，这个请求的RT是最短的；反之，当请求堆积的时候，那么处理请求的时间则会变为：排队时间 + 最短处理时间。</p>\n<ul>\n<li>推论一: 如果我们能够保证水管里的水量，能够让水顺畅的流动，则不会增加排队的请求；也就是说，这个时候的系统负载不会进一步恶化。</li>\n</ul>\n<p>我们用 T 来表示(水管内部的水量)，用RT来表示请求的处理时间，用P来表示进来的请求数，那么一个请求从进入水管道到从水管出来，这个水管会存在 <code>P * RT</code>　个请求。换一句话来说，当 <code>T ≈ QPS * Avg(RT)</code> 的时候，我们可以认为系统的处理能力和允许进入的请求个数达到了平衡，系统的负载不会进一步恶化。</p>\n<p>接下来的问题是，水管的水位是可以达到了一个平衡点，但是这个平衡点只能保证水管的水位不再继续增高，但是还面临一个问题，就是在达到平衡点之前，这个水管里已经堆积了多少水。如果之前水管的水已经在一个量级了，那么这个时候系统允许通过的水量可能只能缓慢通过，RT会大，之前堆积在水管里的水会滞留；反之，如果之前的水管水位偏低，那么又会浪费了系统的处理能力。</p>\n<ul>\n<li>推论二:　当保持入口的流量是水管出来的流量的最大的值的时候，可以最大利用水管的处理能力。</li>\n</ul>\n<p>然而，和 TCP BBR 的不一样的地方在于，还需要用一个系统负载的值（load1）来激发这套机制启动。</p>\n<blockquote>\n<p>这种系统自适应算法对于低 load 的请求，它的效果是一个“兜底”的角色。<code>对于不是应用本身造成的 load 高的情况（如其它进程导致的不稳定的情况），效果不明显</code>。</p>\n</blockquote>\n<h1 id=\"伍、示例\"><a href=\"#伍、示例\" class=\"headerlink\" title=\"伍、示例\"></a>伍、示例</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SystemGuardDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger pass = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger block = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger total = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> seconds = <span class=\"number\">60</span> + <span class=\"number\">40</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        tick();</span><br><span class=\"line\">        initSystemRule();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">            Thread entryThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                        Entry entry = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            entry = SphU.entry(<span class=\"string\">&quot;methodA&quot;</span>, EntryType.IN);</span><br><span class=\"line\">                            pass.incrementAndGet();</span><br><span class=\"line\">                            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                                TimeUnit.MILLISECONDS.sleep(<span class=\"number\">20</span>);</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                                <span class=\"comment\">// ignore</span></span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (BlockException e1) &#123;</span><br><span class=\"line\">                            block.incrementAndGet();</span><br><span class=\"line\">                            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                                TimeUnit.MILLISECONDS.sleep(<span class=\"number\">20</span>);</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                                <span class=\"comment\">// ignore</span></span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e2) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// biz exception</span></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            total.incrementAndGet();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (entry != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                entry.exit();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            entryThread.setName(<span class=\"string\">&quot;working-thread&quot;</span>);</span><br><span class=\"line\">            entryThread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">initSystemRule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;SystemRule&gt; rules = <span class=\"keyword\">new</span> ArrayList&lt;SystemRule&gt;();</span><br><span class=\"line\">        SystemRule rule = <span class=\"keyword\">new</span> SystemRule();</span><br><span class=\"line\">        <span class=\"comment\">// max load is 3</span></span><br><span class=\"line\">        rule.setHighestSystemLoad(<span class=\"number\">3.0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// max cpu usage is 60%</span></span><br><span class=\"line\">        rule.setHighestCpuUsage(<span class=\"number\">0.6</span>);</span><br><span class=\"line\">        <span class=\"comment\">// max avg rt of all request is 10 ms</span></span><br><span class=\"line\">        rule.setAvgRt(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"comment\">// max total qps is 20</span></span><br><span class=\"line\">        rule.setQps(<span class=\"number\">20</span>);</span><br><span class=\"line\">        <span class=\"comment\">// max parallel working thread is 10</span></span><br><span class=\"line\">        rule.setMaxThread(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        rules.add(rule);</span><br><span class=\"line\">        SystemRuleManager.loadRules(Collections.singletonList(rule));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tick</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread timer = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> TimerTask());</span><br><span class=\"line\">        timer.setName(<span class=\"string\">&quot;sentinel-timer-task&quot;</span>);</span><br><span class=\"line\">        timer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;begin to statistic!!!&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldTotal = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldPass = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldBlock = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalTotal = total.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondTotal = globalTotal - oldTotal;</span><br><span class=\"line\">                oldTotal = globalTotal;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalPass = pass.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondPass = globalPass - oldPass;</span><br><span class=\"line\">                oldPass = globalPass;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalBlock = block.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondBlock = globalBlock - oldBlock;</span><br><span class=\"line\">                oldBlock = globalBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(seconds + <span class=\"string\">&quot;, &quot;</span> + TimeUtil.currentTimeMillis() + <span class=\"string\">&quot;, total:&quot;</span></span><br><span class=\"line\">                    + oneSecondTotal + <span class=\"string\">&quot;, pass:&quot;</span></span><br><span class=\"line\">                    + oneSecondPass + <span class=\"string\">&quot;, block:&quot;</span> + oneSecondBlock);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (seconds-- &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    stop = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践的源码</a> ,包括流量控制和初始规则加载等等。</p>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","raw":null,"categories":[{"name":"sentinel","path":"api/categories/sentinel.json"}],"tags":[{"name":"sentinel","path":"api/tags/sentinel.json"}]},{"title":"Sentinel进阶之熔断降级","slug":"Sentinel进阶之熔断降级","date":"2021-06-06T11:03:25.000Z","updated":"2021-06-07T00:12:02.281Z","comments":true,"path":"api/articles/Sentinel进阶之熔断降级.json","excerpt":null,"keywords":"南国薏米","cover":"https://image.eelve.com/eblog/service-chain.png","content":"<p>【<strong>前面的话</strong>】在前文 <a href=\"https://eelve.com/archives/sentinel-flow-control\">Sentinel进阶之流量</a> 中简单介绍了一下<code>Sentinel</code>的流量控制，今天就来继续说一下Sentinel的熔断降级。</p>\n<hr>\n<h1 id=\"壹、概述\"><a href=\"#壹、概述\" class=\"headerlink\" title=\"壹、概述\"></a>壹、概述</h1><p>除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。</p>\n<p><img src=\"https://image.eelve.com/eblog/service-chain.png\" alt=\"服务调用链\"></p>\n<p>现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的<code>弱依赖服务调用</code>进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。</p>\n<blockquote>\n<p>Sentinel 1.8.0 及以上版本对熔断降级特性进行了全新的改进升级，我们可以选择最新版本体验降级规则熔断。</p>\n</blockquote>\n<h1 id=\"贰、熔断策略\"><a href=\"#贰、熔断策略\" class=\"headerlink\" title=\"贰、熔断策略\"></a>贰、熔断策略</h1><p>Sentinel 提供以下几种熔断策略：</p>\n<ul>\n<li>慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)：选择以慢调用比例作为阈值，需要设置允许的慢调用 <code>RT</code>（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（<code>HALF-OPEN 状态</code>），若接下来的一个请求响应时间小于设置的慢调用 <code>RT</code> 则结束熔断，若大于设置的慢调用 <code>RT</code> 则会再次被熔断。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SlowRatioCircuitBreakerDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  private static final String KEY &#x3D; &quot;some_method&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">  private static volatile boolean stop &#x3D; false;</span><br><span class=\"line\">  private static int seconds &#x3D; 120;</span><br><span class=\"line\"></span><br><span class=\"line\">  private static AtomicInteger total &#x3D; new AtomicInteger();</span><br><span class=\"line\">  private static AtomicInteger pass &#x3D; new AtomicInteger();</span><br><span class=\"line\">  private static AtomicInteger block &#x3D; new AtomicInteger();</span><br><span class=\"line\"></span><br><span class=\"line\">  public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">      initDegradeRule();</span><br><span class=\"line\">      registerStateChangeObserver();</span><br><span class=\"line\">      startTick();</span><br><span class=\"line\"></span><br><span class=\"line\">      int concurrency &#x3D; 8;</span><br><span class=\"line\">      for (int i &#x3D; 0; i &lt; concurrency; i++) &#123;</span><br><span class=\"line\">          Thread entryThread &#x3D; new Thread(() -&gt; &#123;</span><br><span class=\"line\">              while (true) &#123;</span><br><span class=\"line\">                  Entry entry &#x3D; null;</span><br><span class=\"line\">                  try &#123;</span><br><span class=\"line\">                      entry &#x3D; SphU.entry(KEY);</span><br><span class=\"line\">                      pass.incrementAndGet();</span><br><span class=\"line\">                      &#x2F;&#x2F; RT: [40ms, 60ms)</span><br><span class=\"line\">                      sleep(ThreadLocalRandom.current().nextInt(40, 60));</span><br><span class=\"line\">                  &#125; catch (BlockException e) &#123;</span><br><span class=\"line\">                      block.incrementAndGet();</span><br><span class=\"line\">                      sleep(ThreadLocalRandom.current().nextInt(5, 10));</span><br><span class=\"line\">                  &#125; finally &#123;</span><br><span class=\"line\">                      total.incrementAndGet();</span><br><span class=\"line\">                      if (entry !&#x3D; null) &#123;</span><br><span class=\"line\">                          entry.exit();</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          entryThread.setName(&quot;sentinel-simulate-traffic-task-&quot; + i);</span><br><span class=\"line\">          entryThread.start();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  private static void registerStateChangeObserver() &#123;</span><br><span class=\"line\">      EventObserverRegistry.getInstance().addStateChangeObserver(&quot;logging&quot;,</span><br><span class=\"line\">          (prevState, newState, rule, snapshotValue) -&gt; &#123;</span><br><span class=\"line\">              if (newState &#x3D;&#x3D; State.OPEN) &#123;</span><br><span class=\"line\">                  System.err.println(String.format(&quot;%s -&gt; OPEN at %d, snapshotValue&#x3D;%.2f&quot;, prevState.name(),</span><br><span class=\"line\">                      TimeUtil.currentTimeMillis(), snapshotValue));</span><br><span class=\"line\">              &#125; else &#123;</span><br><span class=\"line\">                  System.err.println(String.format(&quot;%s -&gt; %s at %d&quot;, prevState.name(), newState.name(),</span><br><span class=\"line\">                      TimeUtil.currentTimeMillis()));</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  private static void initDegradeRule() &#123;</span><br><span class=\"line\">      List&lt;DegradeRule&gt; rules &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">      DegradeRule rule &#x3D; new DegradeRule(KEY)</span><br><span class=\"line\">          .setGrade(CircuitBreakerStrategy.SLOW_REQUEST_RATIO.getType())</span><br><span class=\"line\">          &#x2F;&#x2F; Max allowed response time</span><br><span class=\"line\">          .setCount(50)</span><br><span class=\"line\">          &#x2F;&#x2F; Retry timeout (in second)</span><br><span class=\"line\">          .setTimeWindow(10)</span><br><span class=\"line\">          &#x2F;&#x2F; Circuit breaker opens when slow request ratio &gt; 60%</span><br><span class=\"line\">          .setSlowRatioThreshold(0.6)</span><br><span class=\"line\">          .setMinRequestAmount(100)</span><br><span class=\"line\">          .setStatIntervalMs(20000);</span><br><span class=\"line\">      rules.add(rule);</span><br><span class=\"line\"></span><br><span class=\"line\">      DegradeRuleManager.loadRules(rules);</span><br><span class=\"line\">      System.out.println(&quot;Degrade rule loaded: &quot; + rules);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  private static void sleep(int timeMs) &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">          TimeUnit.MILLISECONDS.sleep(timeMs);</span><br><span class=\"line\">      &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">          &#x2F;&#x2F; ignore</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  private static void startTick() &#123;</span><br><span class=\"line\">      Thread timer &#x3D; new Thread(new TimerTask());</span><br><span class=\"line\">      timer.setName(&quot;sentinel-timer-tick-task&quot;);</span><br><span class=\"line\">      timer.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static class TimerTask implements Runnable &#123;</span><br><span class=\"line\">      @Override</span><br><span class=\"line\">      public void run() &#123;</span><br><span class=\"line\">          long start &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">          System.out.println(&quot;Begin to run! Go go go!&quot;);</span><br><span class=\"line\">          System.out.println(&quot;See corresponding metrics.log for accurate statistic data&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">          long oldTotal &#x3D; 0;</span><br><span class=\"line\">          long oldPass &#x3D; 0;</span><br><span class=\"line\">          long oldBlock &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">          while (!stop) &#123;</span><br><span class=\"line\">              sleep(1000);</span><br><span class=\"line\"></span><br><span class=\"line\">              long globalTotal &#x3D; total.get();</span><br><span class=\"line\">              long oneSecondTotal &#x3D; globalTotal - oldTotal;</span><br><span class=\"line\">              oldTotal &#x3D; globalTotal;</span><br><span class=\"line\"></span><br><span class=\"line\">              long globalPass &#x3D; pass.get();</span><br><span class=\"line\">              long oneSecondPass &#x3D; globalPass - oldPass;</span><br><span class=\"line\">              oldPass &#x3D; globalPass;</span><br><span class=\"line\"></span><br><span class=\"line\">              long globalBlock &#x3D; block.get();</span><br><span class=\"line\">              long oneSecondBlock &#x3D; globalBlock - oldBlock;</span><br><span class=\"line\">              oldBlock &#x3D; globalBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">              System.out.println(TimeUtil.currentTimeMillis() + &quot;, total:&quot; + oneSecondTotal</span><br><span class=\"line\">                  + &quot;, pass:&quot; + oneSecondPass + &quot;, block:&quot; + oneSecondBlock);</span><br><span class=\"line\"></span><br><span class=\"line\">              if (seconds-- &lt;&#x3D; 0) &#123;</span><br><span class=\"line\">                  stop &#x3D; true;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          long cost &#x3D; System.currentTimeMillis() - start;</span><br><span class=\"line\">          System.out.println(&quot;time cost: &quot; + cost + &quot; ms&quot;);</span><br><span class=\"line\">          System.out.println(&quot;total: &quot; + total.get() + &quot;, pass:&quot; + pass.get()</span><br><span class=\"line\">              + &quot;, block:&quot; + block.get());</span><br><span class=\"line\">          System.exit(0);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>异常比例 (<code>ERROR_RATIO</code>)：当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（<code>HALF-OPEN 状态</code>），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 <code>0% - 100%</code>。</li>\n<li>异常数 (<code>ERROR_COUNT</code>)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（<code>HALF-OPEN 状态</code>），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li>\n</ul>\n<p>注意异常降级仅针对业务异常，对 <code>Sentinel</code> 限流降级本身的异常（<code>BlockException</code>）不生效。为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常。示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Entry entry = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  entry = SphU.entry(resource);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Write your biz code here.</span></span><br><span class=\"line\">  <span class=\"comment\">// &lt;&lt;BIZ CODE&gt;&gt;</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!BlockException.isBlockException(t)) &#123;</span><br><span class=\"line\">    Tracer.trace(t);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (entry != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    entry.exit();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>开源整合模块，如 <code>Sentinel Dubbo Adapter</code>, <code>Sentinel Web Servlet Filter</code> 或 <code>@SentinelResource</code> 注解会自动统计业务异常，无需手动调用。但是如果你的程序发生异常的异常被处理过，或者异常时并不会抛出异常，则需要你自己手动调用 <code>Tracer.trace(ex)</code> 来记录业务异常。否则你的<code>异常比例</code>和<code>异常数</code>将不会生效。</p>\n</blockquote>\n<h1 id=\"叁、熔断降级规则说明\"><a href=\"#叁、熔断降级规则说明\" class=\"headerlink\" title=\"叁、熔断降级规则说明\"></a>叁、熔断降级规则说明</h1><p>熔断降级规则（DegradeRule）包含下面几个重要的属性：</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>resource</td>\n<td>资源名，即规则的作用对象</td>\n<td></td>\n</tr>\n<tr>\n<td>grade</td>\n<td>熔断策略，支持慢调用比例/异常比例/异常数策略</td>\n<td>慢调用比例</td>\n</tr>\n<tr>\n<td>count</td>\n<td>慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例/异常数模式下为对应的阈值</td>\n<td></td>\n</tr>\n<tr>\n<td>timeWindow</td>\n<td>熔断时长，单位为 s</td>\n<td></td>\n</tr>\n<tr>\n<td>minRequestAmount</td>\n<td>熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）</td>\n<td>5</td>\n</tr>\n<tr>\n<td>statIntervalMs</td>\n<td>统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）</td>\n<td>1000 ms</td>\n</tr>\n<tr>\n<td>slowRatioThreshold</td>\n<td>慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"肆、熔断器事件监听\"><a href=\"#肆、熔断器事件监听\" class=\"headerlink\" title=\"肆、熔断器事件监听\"></a>肆、熔断器事件监听</h1><p><code>Sentinel</code> 支持注册自定义的事件监听器监听熔断器状态变换事件（state change event）。示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventObserverRegistry.getInstance().addStateChangeObserver(<span class=\"string\">&quot;logging&quot;</span>,</span><br><span class=\"line\">    (prevState, newState, rule, snapshotValue) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newState == State.OPEN) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 变换至 OPEN state 时会携带触发时的值</span></span><br><span class=\"line\">            System.err.println(String.format(<span class=\"string\">&quot;%s -&gt; OPEN at %d, snapshotValue=%.2f&quot;</span>, prevState.name(),</span><br><span class=\"line\">                TimeUtil.currentTimeMillis(), snapshotValue));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.err.println(String.format(<span class=\"string\">&quot;%s -&gt; %s at %d&quot;</span>, prevState.name(), newState.name(),</span><br><span class=\"line\">                TimeUtil.currentTimeMillis()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践的源码</a> ,包括流量控制和初始规则加载等等。</p>\n<p>另外在使用<code>API</code>去加载规则的时候，发现存在规则不生效的时候，通过调试发现：<code>Sentinel</code>在加载规则到内存中的时候会校验规则的合法性，如果规则不合法，该规则将不被加载。</p>\n<p>具体可以查看<code>com.alibaba.csp.sentinel.property#configLoad</code>方法的实现类中参数校验方法，下面贴出<code>DegradeRule</code> 的校验方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public static boolean isValidRule(DegradeRule rule) &#123;</span><br><span class=\"line\">    boolean baseValid &#x3D; rule !&#x3D; null &amp;&amp; !StringUtil.isBlank(rule.getResource())</span><br><span class=\"line\">        &amp;&amp; rule.getCount() &gt;&#x3D; 0 &amp;&amp; rule.getTimeWindow() &gt; 0;</span><br><span class=\"line\">    if (!baseValid) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (rule.getMinRequestAmount() &lt;&#x3D; 0 || rule.getStatIntervalMs() &lt;&#x3D; 0) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    switch (rule.getGrade()) &#123;</span><br><span class=\"line\">        case RuleConstant.DEGRADE_GRADE_RT:</span><br><span class=\"line\">            return rule.getSlowRatioThreshold() &gt;&#x3D; 0 &amp;&amp; rule.getSlowRatioThreshold() &lt;&#x3D; 1;</span><br><span class=\"line\">        case RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO:</span><br><span class=\"line\">            return rule.getCount() &lt;&#x3D; 1;</span><br><span class=\"line\">        case RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT:</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","raw":null,"categories":[{"name":"sentinel","path":"api/categories/sentinel.json"}],"tags":[{"name":"sentinel","path":"api/tags/sentinel.json"}]},{"title":"Sentinel进阶之流量控制","slug":"Sentinel进阶之流量控制","date":"2021-06-06T04:50:28.000Z","updated":"2021-06-06T11:36:01.884Z","comments":true,"path":"api/articles/Sentinel进阶之流量控制.json","excerpt":null,"keywords":"南国薏米","cover":"https://image.eelve.com/eblog/warmup.gif","content":"<p>【<strong>前面的话</strong>】在前文 <a href=\"https://eelve.com/archives/sentinel-implementation\">Sentinel进阶之基本原理</a> 中简单介绍了一下<code>Sentinel</code>的基本原理，今天就来具体说一下<code>Sentinel</code>的流量控制。</p>\n<hr>\n<p>壹、概述</p>\n<p><code>FlowSlot</code> 会根据预设的规则，结合前面 <code>NodeSelectorSlot</code>、<code>ClusterNodeBuilderSlot</code>、<code>StatistcSlot</code> 统计出来的实时信息进行流量控制。</p>\n<p>限流的直接表现是在执行 <code>Entry nodeA = SphU.entry(资源名字)</code> 的时候抛出 <code>FlowException</code> 异常。<code>FlowException</code> 是 <code>BlockException</code> 的子类，您可以捕捉 <code>BlockException</code> 来自定义被限流之后的处理逻辑。</p>\n<p>同一个资源可以对应多条限流规则。<code>FlowSlot</code> 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p>\n<p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p>\n<ul>\n<li><code>resource</code>：资源名，即限流规则的作用对象 </li>\n<li><code>count</code>: 限流阈值</li>\n<li><code>grade</code>: 限流阈值类型，QPS 或线程数</li>\n<li><code>strategy</code>: 根据调用关系选择策略</li>\n</ul>\n<p>贰、基于QPS/并发数的流量控制</p>\n<p>流量控制主要有两种统计类型，一种是统计<code>线程数</code>，另外一种则是统计 <code>QPS</code>。类型由 <code>FlowRule.grade</code> 字段来定义。其中，<code>0</code> 代表根据并发数量来限流，<code>1</code> 代表根据 QPS 来进行流量控制。其中<code>线程数</code>、<code>QPS</code> 值，都是由 <code>StatisticSlot</code> 实时统计获取的。</p>\n<p>可以通过下面的命令查看实时统计信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http:&#x2F;&#x2F;localhost:8719&#x2F;cnode?id&#x3D;resourceName</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>8719</code>端口可以通过配置文件修改</p>\n</blockquote>\n<p>输出内容格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">idx id   thread  pass  blocked   success  total Rt   1m-pass   1m-block   1m-all   exeption</span><br><span class=\"line\">2   abc647 0     46     0           46     46   1       2763      0         2763     0</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<ul>\n<li>thread： 代表当前处理该资源的线程数；</li>\n<li>pass： 代表一秒内到来到的请求；</li>\n<li>blocked： 代表一秒内被流量控制的请求数量；</li>\n<li>success： 代表一秒内成功处理完的请求；</li>\n<li>total： 代表到一秒内到来的请求以及被阻止的请求总和；</li>\n<li>RT： 代表一秒内该资源的平均响应时间；</li>\n<li>1m-pass： 则是一分钟内到来的请求；</li>\n<li>1m-block： 则是一分钟内被阻止的请求；</li>\n<li>1m-all： 则是一分钟内到来的请求和被阻止的请求的总和；</li>\n<li>exception： 则是一秒内业务本身异常的总和。</li>\n</ul>\n<h2 id=\"2-1、并发线程数流量控制\"><a href=\"#2-1、并发线程数流量控制\" class=\"headerlink\" title=\"2.1、并发线程数流量控制\"></a>2.1、并发线程数流量控制</h2><p>线程数限流用于保护业务线程数不被耗尽。例如，当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。为应对高线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离），或者使用信号量来控制同时请求的个数（信号量隔离）。这种隔离方案虽然能够控制线程数量，但无法控制请求排队时间。当请求过多时排队也是无益的，直接拒绝能够迅速降低系统压力。Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlowThreadDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger pass = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger block = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger total = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger activeThread = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> seconds = <span class=\"number\">60</span> + <span class=\"number\">40</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> methodBRunningTime = <span class=\"number\">2000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(</span><br><span class=\"line\">            <span class=\"string\">&quot;MethodA will call methodB. After running for a while, methodB becomes fast, &quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;which make methodA also become fast &quot;</span>);</span><br><span class=\"line\">        tick();</span><br><span class=\"line\">        initFlowRule();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">            Thread entryThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                        Entry methodA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            TimeUnit.MILLISECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">                            methodA = SphU.entry(<span class=\"string\">&quot;methodA&quot;</span>);</span><br><span class=\"line\">                            activeThread.incrementAndGet();</span><br><span class=\"line\">                            Entry methodB = SphU.entry(<span class=\"string\">&quot;methodB&quot;</span>);</span><br><span class=\"line\">                            TimeUnit.MILLISECONDS.sleep(methodBRunningTime);</span><br><span class=\"line\">                            methodB.exit();</span><br><span class=\"line\">                            pass.addAndGet(<span class=\"number\">1</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (BlockException e1) &#123;</span><br><span class=\"line\">                            block.incrementAndGet();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e2) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// biz exception</span></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            total.incrementAndGet();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (methodA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                methodA.exit();</span><br><span class=\"line\">                                activeThread.decrementAndGet();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            entryThread.setName(<span class=\"string\">&quot;working thread&quot;</span>);</span><br><span class=\"line\">            entryThread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">initFlowRule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;FlowRule&gt; rules = <span class=\"keyword\">new</span> ArrayList&lt;FlowRule&gt;();</span><br><span class=\"line\">        FlowRule rule1 = <span class=\"keyword\">new</span> FlowRule();</span><br><span class=\"line\">        rule1.setResource(<span class=\"string\">&quot;methodA&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// set limit concurrent thread for &#x27;methodA&#x27; to 20</span></span><br><span class=\"line\">        rule1.setCount(<span class=\"number\">20</span>);</span><br><span class=\"line\">        rule1.setGrade(RuleConstant.FLOW_GRADE_THREAD);</span><br><span class=\"line\">        rule1.setLimitApp(<span class=\"string\">&quot;default&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        rules.add(rule1);</span><br><span class=\"line\">        FlowRuleManager.loadRules(rules);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tick</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread timer = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> TimerTask());</span><br><span class=\"line\">        timer.setName(<span class=\"string\">&quot;sentinel-timer-task&quot;</span>);</span><br><span class=\"line\">        timer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;begin to statistic!!!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldTotal = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldPass = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> oldBlock = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalTotal = total.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondTotal = globalTotal - oldTotal;</span><br><span class=\"line\">                oldTotal = globalTotal;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalPass = pass.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondPass = globalPass - oldPass;</span><br><span class=\"line\">                oldPass = globalPass;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">long</span> globalBlock = block.get();</span><br><span class=\"line\">                <span class=\"keyword\">long</span> oneSecondBlock = globalBlock - oldBlock;</span><br><span class=\"line\">                oldBlock = globalBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(seconds + <span class=\"string\">&quot; total qps is: &quot;</span> + oneSecondTotal);</span><br><span class=\"line\">                System.out.println(TimeUtil.currentTimeMillis() + <span class=\"string\">&quot;, total:&quot;</span> + oneSecondTotal</span><br><span class=\"line\">                    + <span class=\"string\">&quot;, pass:&quot;</span> + oneSecondPass</span><br><span class=\"line\">                    + <span class=\"string\">&quot;, block:&quot;</span> + oneSecondBlock</span><br><span class=\"line\">                    + <span class=\"string\">&quot; activeThread:&quot;</span> + activeThread.get());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (seconds-- &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    stop = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (seconds == <span class=\"number\">40</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;method B is running much faster; more requests are allowed to pass&quot;</span>);</span><br><span class=\"line\">                    methodBRunningTime = <span class=\"number\">20</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> cost = System.currentTimeMillis() - start;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;time cost: &quot;</span> + cost + <span class=\"string\">&quot; ms&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;total:&quot;</span> + total.get() + <span class=\"string\">&quot;, pass:&quot;</span> + pass.get()</span><br><span class=\"line\">                + <span class=\"string\">&quot;, block:&quot;</span> + block.get());</span><br><span class=\"line\">            System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、QPS流量控制\"><a href=\"#2-2、QPS流量控制\" class=\"headerlink\" title=\"2.2、QPS流量控制\"></a>2.2、QPS流量控制</h2><p>当 <code>QPS</code> 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括下面 3 种，对应 <code>FlowRule</code> 中的 <code>controlBehavior</code> 字段：</p>\n<ul>\n<li><p>1、直接拒绝（<code>RuleConstant.CONTROL_BEHAVIOR_DEFAULT</code>）方式。该方式是默认的流量控制方式，当<code>QPS</code>超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。</p>\n</li>\n<li><p>2、冷启动（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式。该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</p>\n<p>  通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：<br>  <img src=\"https://image.eelve.com/eblog/warmup.gif\" alt=\"冷启动\"></p>\n</li>\n<li><p>3、匀速器（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p>\n<p>  <img src=\"https://image.eelve.com/eblog/queue.gif\" alt=\"排队\"></p>\n<p>  这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p>\n</li>\n</ul>\n<p>叁、基于调用关系的流量控制</p>\n<p>调用关系包括调用方、被调用方；方法又可能会调用其它方法，形成一个调用链路的层次关系。<code>Sentinel</code> 通过 <code>NodeSelectorSlot</code> 建立不同资源间的调用的关系，并且通过 <code>ClusterNodeBuilderSlot</code> 记录每个资源的实时统计信息。</p>\n<p>有了调用链路的统计信息，我们可以衍生出多种流量控制手段。</p>\n<h2 id=\"3-1-根据调用方限流\"><a href=\"#3-1-根据调用方限流\" class=\"headerlink\" title=\"3.1 根据调用方限流\"></a>3.1 根据调用方限流</h2><p><code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数标明了调用方身份。这些信息会在 <code>ClusterBuilderSlot</code> 中被统计。可通过以下命令来展示不同的调用方对同一个资源的调用数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http:&#x2F;&#x2F;localhost:8719&#x2F;origin?id&#x3D;nodeA</span><br></pre></td></tr></table></figure>\n<p>调用数据示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id: nodeA</span><br><span class=\"line\">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class=\"line\">1   caller1 0         0         0          0        0     0         0          0</span><br><span class=\"line\">2   caller2 0         0         0          0        0     0         0          0</span><br></pre></td></tr></table></figure>\n<p>上面这个命令展示了资源名为 <code>nodeA</code> 的资源被两个不同的调用方调用的统计。</p>\n<p>限流规则中的 <code>limitApp</code> 字段用于根据调用方进行流量控制。该字段的值有以下三种选项，分别对应不同的场景：</p>\n<ul>\n<li><code>default</code>：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。</li>\n<li><code>&#123;some_origin_name&#125;</code>：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 <code>NodeA</code> 配置了一条针对调用者<code>caller1</code>的规则，那么当且仅当来自 <code>caller1</code> 对 <code>NodeA</code> 的请求才会触发流量控制。</li>\n<li><code>other</code>：表示针对除 <code>&#123;some_origin_name&#125;</code> 以外的其余调用方的流量进行流量控制。例如，资源<code>NodeA</code>配置了一条针对调用者 <code>caller1</code> 的限流规则，同时又配置了一条调用者为 <code>other</code> 的规则，那么任意来自非 <code>caller1</code> 对 <code>NodeA</code> 的调用，都不能超过 <code>other</code> 这条规则定义的阈值。</li>\n</ul>\n<blockquote>\n<p>同一个资源名可以配置多条规则，规则的生效顺序为：{some_origin_name} &gt; other &gt; default</p>\n</blockquote>\n<h2 id=\"3-2-根据调用链路入口限流：链路限流\"><a href=\"#3-2-根据调用链路入口限流：链路限流\" class=\"headerlink\" title=\"3.2 根据调用链路入口限流：链路限流\"></a>3.2 根据调用链路入口限流：链路限流</h2><p><code>NodeSelectorSlot</code> 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 <code>machine-root</code> 的虚拟节点，调用链的入口都是这个虚节点的子节点。</p>\n<p>一棵典型的调用树如下图所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">          machine-root</span><br><span class=\"line\">              &#x2F;       \\</span><br><span class=\"line\">             &#x2F;         \\</span><br><span class=\"line\">       Entrance1     Entrance2</span><br><span class=\"line\">          &#x2F;             \\</span><br><span class=\"line\">         &#x2F;               \\</span><br><span class=\"line\">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure>\n<p>上图中来自入口 <code>Entrance1</code> 和 <code>Entrance2</code> 的请求都调用到了资源 <code>NodeA</code>，<code>Sentinel</code> 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 <code>FlowRule.strategy</code> 为 <code>RuleConstant.CHAIN</code>，同时设置 <code>FlowRule.ref_identity</code> 为 <code>Entrance1</code> 来表示只有从入口 <code>Entrance1</code> 的调用才会记录到 <code>NodeA</code> 的限流统计当中，而对来自 <code>Entrance2</code> 的调用漠不关心。</p>\n<p>调用链的入口是通过 <code>API</code> 方法 <code>ContextUtil.enter(name)</code> 定义的。</p>\n<h2 id=\"3-3-具有关系的资源流量控制：关联流量控制\"><a href=\"#3-3-具有关系的资源流量控制：关联流量控制\" class=\"headerlink\" title=\"3.3 具有关系的资源流量控制：关联流量控制\"></a>3.3 具有关系的资源流量控制：关联流量控制</h2><p>当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，<code>read_db</code> 和 <code>write_db</code> 这两个资源分别代表数据库读写，我们可以给 <code>read_db</code> 设置限流规则来达到写优先的目的：设置 <code>FlowRule.strategy</code> 为 <code>RuleConstant.RELATE</code> 同时设置 <code>FlowRule.ref_identity</code> 为 <code>write_db</code>。这样当写库操作过于频繁时，读数据的请求会被限流。</p>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践的源码</a> ,包括流量控制和初始规则加载等等。</p>\n<p>另外在使用<code>API</code>去加载规则的时候，发现存在规则不生效的时候，通过调试发现：<code>Sentinel</code>在加载规则到内存中的时候会校验规则的合法性，如果规则不合法，该规则将不被加载。</p>\n<p>具体可以查看<code>com.alibaba.csp.sentinel.property#configLoad</code>方法的实现类中参数校验方法，下面贴出<code>FlowRule</code> 的校验方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Check whether provided flow rule is valid.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param rule flow rule to check</span><br><span class=\"line\"> * @return true if valid, otherwise false</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public static boolean isValidRule(FlowRule rule) &#123;</span><br><span class=\"line\">    boolean baseValid &#x3D; rule !&#x3D; null &amp;&amp; !StringUtil.isBlank(rule.getResource()) &amp;&amp; rule.getCount() &gt;&#x3D; 0</span><br><span class=\"line\">        &amp;&amp; rule.getGrade() &gt;&#x3D; 0 &amp;&amp; rule.getStrategy() &gt;&#x3D; 0 &amp;&amp; rule.getControlBehavior() &gt;&#x3D; 0;</span><br><span class=\"line\">    if (!baseValid) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; Check strategy and control (shaping) behavior.</span><br><span class=\"line\">    return checkClusterField(rule) &amp;&amp; checkStrategyField(rule) &amp;&amp; checkControlBehaviorField(rule);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static boolean checkClusterField(&#x2F;*@NonNull*&#x2F; FlowRule rule) &#123;</span><br><span class=\"line\">    if (!rule.isClusterMode()) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ClusterFlowConfig clusterConfig &#x3D; rule.getClusterConfig();</span><br><span class=\"line\">    if (clusterConfig &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!validClusterRuleId(clusterConfig.getFlowId())) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!isWindowConfigValid(clusterConfig.getSampleCount(), clusterConfig.getWindowIntervalMs())) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    switch (clusterConfig.getStrategy()) &#123;</span><br><span class=\"line\">        case ClusterRuleConstant.FLOW_CLUSTER_STRATEGY_NORMAL:</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static boolean isWindowConfigValid(int sampleCount, int windowIntervalMs) &#123;</span><br><span class=\"line\">    return sampleCount &gt; 0 &amp;&amp; windowIntervalMs &gt; 0 &amp;&amp; windowIntervalMs % sampleCount &#x3D;&#x3D; 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static boolean checkStrategyField(&#x2F;*@NonNull*&#x2F; FlowRule rule) &#123;</span><br><span class=\"line\">    if (rule.getStrategy() &#x3D;&#x3D; RuleConstant.STRATEGY_RELATE || rule.getStrategy() &#x3D;&#x3D; RuleConstant.STRATEGY_CHAIN) &#123;</span><br><span class=\"line\">        return StringUtil.isNotBlank(rule.getRefResource());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static boolean checkControlBehaviorField(&#x2F;*@NonNull*&#x2F; FlowRule rule) &#123;</span><br><span class=\"line\">    switch (rule.getControlBehavior()) &#123;</span><br><span class=\"line\">        case RuleConstant.CONTROL_BEHAVIOR_WARM_UP:</span><br><span class=\"line\">            return rule.getWarmUpPeriodSec() &gt; 0;</span><br><span class=\"line\">        case RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER:</span><br><span class=\"line\">            return rule.getMaxQueueingTimeMs() &gt; 0;</span><br><span class=\"line\">        case RuleConstant.CONTROL_BEHAVIOR_WARM_UP_RATE_LIMITER:</span><br><span class=\"line\">            return rule.getWarmUpPeriodSec() &gt; 0 &amp;&amp; rule.getMaxQueueingTimeMs() &gt; 0;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","raw":null,"categories":[{"name":"sentinel","path":"api/categories/sentinel.json"}],"tags":[{"name":"sentinel","path":"api/tags/sentinel.json"}]},{"title":"Sentinel进阶之基本原理","slug":"Sentinel进阶之基本原理","date":"2021-05-30T05:01:11.000Z","updated":"2021-06-06T05:29:58.762Z","comments":true,"path":"api/articles/Sentinel进阶之基本原理.json","excerpt":null,"keywords":"南国薏米","cover":"https://image.eelve.com/eblog/2021053001.png","content":"<p>【<strong>前面的话</strong>】在前文 <a href=\"https://eelve.com/archives/hellosentinel\">Sentinel入门指北</a> 中简单介绍了一下<code>Sentinel</code>，今天就来具体说一下<code>Sentinel</code>的基本原理。</p>\n<hr>\n<h1 id=\"壹、概述\"><a href=\"#壹、概述\" class=\"headerlink\" title=\"壹、概述\"></a>壹、概述</h1><p>在 <code>Sentinel</code> 里面，所有的资源都对应一个资源名称以及一个 <code>Entry</code>。<code>Entry</code> 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 <code>API</code> 显式创建；每一个 <code>Entry</code> 创建的时候，同时也会创建一系列功能插槽（slot chain）。这些插槽有不同的职责，例如:</p>\n<ul>\n<li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级； </li>\n<li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如该资源的 <code>RT</code>, <code>QPS</code>, <code>thread count</code> 等等，这些信息将用作为多维度限流，降级的依据；</li>\n<li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 <code>runtime</code> 指标监控信息；</li>\n<li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 <code>slot</code> 统计的状态，来进行流量控制；</li>\n<li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li>\n<li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li>\n<li><code>SystemSlot</code> 则通过系统的状态，例如 <code>load1</code> 等，来控制总的入口流量；</li>\n</ul>\n<p>总体的框架如下:</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053001.png\" alt=\"总体框架图\"></p>\n<p><code>Sentinel</code> 将 <code>ProcessorSlot</code> 作为 <code>SPI</code> 接口进行扩展（1.7.2 版本以前 <code>SlotChainBuilder</code> 作为 <code>SPI</code>），使得 <code>Slot Chain</code> 具备了扩展的能力。您可以自行加入自定义的 <code>slot</code> 并编排 <code>slot</code> 间的顺序，从而可以给 <code>Sentinel</code> 添加自定义的功能。</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053002.png\" alt=\"自定义处理流程\"></p>\n<p>下面介绍一下各个 <code>slot</code> 的功能。</p>\n<h2 id=\"1-1、NodeSelectorSlot\"><a href=\"#1-1、NodeSelectorSlot\" class=\"headerlink\" title=\"1.1、NodeSelectorSlot\"></a>1.1、NodeSelectorSlot</h2><p>这个 <code>slot</code> 主要负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContextUtil.enter(<span class=\"string\">&quot;entrance1&quot;</span>, <span class=\"string\">&quot;appA&quot;</span>);</span><br><span class=\"line\">Entry nodeA = SphU.entry(<span class=\"string\">&quot;nodeA&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nodeA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   nodeA.exit();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ContextUtil.exit();</span><br></pre></td></tr></table></figure>\n<p>上述代码通过 <code>ContextUtil.enter()</code> 创建了一个名为 <code>entrance1</code> 的上下文，同时指定调用发起者为 <code>appA</code>；接着通过 <code>SphU.entry()</code>请求一个 <code>token</code>，如果该方法顺利执行没有抛 <code>BlockException</code>，表明 <code>token</code> 请求成功。</p>\n<p>以上代码将在内存中生成以下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> machine-root</span><br><span class=\"line\">           &#x2F;     </span><br><span class=\"line\">          &#x2F;</span><br><span class=\"line\">   EntranceNode1</span><br><span class=\"line\">        &#x2F;</span><br><span class=\"line\">       &#x2F;   </span><br><span class=\"line\">DefaultNode(nodeA)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：每个 <code>DefaultNode</code> 由资源 <code>ID</code> 和输入名称来标识。换句话说，一个资源 <code>ID</code> 可以有多个不同入口的 <code>DefaultNode</code>。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContextUtil.enter(<span class=\"string\">&quot;entrance1&quot;</span>, <span class=\"string\">&quot;appA&quot;</span>);</span><br><span class=\"line\">Entry nodeA = SphU.entry(<span class=\"string\">&quot;nodeA&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nodeA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  nodeA.exit();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ContextUtil.exit();</span><br><span class=\"line\"></span><br><span class=\"line\">ContextUtil.enter(<span class=\"string\">&quot;entrance2&quot;</span>, <span class=\"string\">&quot;appA&quot;</span>);</span><br><span class=\"line\">nodeA = SphU.entry(<span class=\"string\">&quot;nodeA&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nodeA != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  nodeA.exit();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ContextUtil.exit();</span><br></pre></td></tr></table></figure>\n<p>以上代码将在内存中生成以下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">            machine-root</span><br><span class=\"line\">            &#x2F;         \\</span><br><span class=\"line\">           &#x2F;           \\</span><br><span class=\"line\">   EntranceNode1   EntranceNode2</span><br><span class=\"line\">         &#x2F;               \\</span><br><span class=\"line\">        &#x2F;                 \\</span><br><span class=\"line\">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure>\n<p>上面的结构可以通过调用 <code>curl http://localhost:8719/tree?type=root</code> 来显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EntranceNode: machine-root(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">-EntranceNode1: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">-EntranceNode2: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\">--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class=\"line\"></span><br><span class=\"line\">t:threadNum  pq:passQps  bq:blockedQps  tq:totalQps  rt:averageRt  prq: passRequestQps 1mp:1m-passed 1mb:1m-blocked 1mt:1m-total</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2、ClusterBuilderSlot\"><a href=\"#1-2、ClusterBuilderSlot\" class=\"headerlink\" title=\"1.2、ClusterBuilderSlot\"></a>1.2、ClusterBuilderSlot</h2><p>此插槽用于构建资源的 <code>ClusterNode</code> 以及调用来源节点。<code>ClusterNode</code> 保持资源运行统计信息（响应时间、QPS、block 数目、线程数、异常数等）以及原始调用者统计信息列表。来源调用者的名字由 <code>ContextUtil.enter(contextName，origin)</code> 中的 <code>origin</code> 标记。可通过如下命令查看某个资源不同调用者的访问情况：<code>curl http://localhost:8719/origin?id=caller</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id: nodeA</span><br><span class=\"line\">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class=\"line\">1   caller1 0         0         0          0        0     0         0          0        </span><br><span class=\"line\">2   caller2 0         0         0          0        0     0         0          0      </span><br></pre></td></tr></table></figure>\n<h2 id=\"1-3、StatisticSlot\"><a href=\"#1-3、StatisticSlot\" class=\"headerlink\" title=\"1.3、StatisticSlot\"></a>1.3、StatisticSlot</h2><p><code>StatisticSlot</code> 是 <code>Sentinel</code> 的核心功能插槽之一，用于统计实时的调用数据。</p>\n<ul>\n<li><code>clusterNode</code>：资源唯一标识的 <code>ClusterNode</code> 的 <code>runtime</code> 统计 </li>\n<li><code>origin</code>：根据来自不同调用者的统计信息</li>\n<li><code>defaultnode</code>: 根据上下文条目名称和资源 <code>ID</code> 的 <code>runtime</code> 统计</li>\n<li>入口的统计</li>\n</ul>\n<p><code>Sentinel</code> 底层采用高性能的滑动窗口数据结构 <code>LeapArray</code> 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053003.png\" alt=\"滑动窗口\"></p>\n<h2 id=\"1-4、FlowSlot\"><a href=\"#1-4、FlowSlot\" class=\"headerlink\" title=\"1.4、FlowSlot\"></a>1.4、FlowSlot</h2><p>这个 <code>slot</code> 主要根据预设的资源的统计信息，按照固定的次序，依次生效。如果一个资源对应两条或者多条流控规则，则会根据如下次序依次检验，直到全部通过或者有一个规则生效为止:</p>\n<ul>\n<li>指定应用生效的规则，即针对调用方限流的；</li>\n<li>调用方为 other 的规则；</li>\n<li>调用方为 default 的规则。</li>\n</ul>\n<h2 id=\"1-5、DegradeSlot\"><a href=\"#1-5、DegradeSlot\" class=\"headerlink\" title=\"1.5、DegradeSlot\"></a>1.5、DegradeSlot</h2><p>这个 <code>slot</code> 主要针对资源的平均响应时间（RT）以及异常比率，来决定资源是否在接下来的时间被自动熔断掉。</p>\n<h2 id=\"1-6、SystemSlot\"><a href=\"#1-6、SystemSlot\" class=\"headerlink\" title=\"1.6、SystemSlot\"></a>1.6、SystemSlot</h2><p>这个 <code>slot</code> 会根据对于当前系统的整体情况，对入口资源的调用进行动态调配。其原理是让入口的流量和当前系统的预计容量达到一个动态平衡。</p>\n<p>注意系统规则只对入口流量起作用（调用类型为 <code>EntryType.IN</code>），对出口流量无效。可通过 <code>SphU.entry(res, entryType)</code> 指定调用类型，如果不指定，默认是<code>EntryType.OUT</code>。</p>\n<h1 id=\"贰、-核心类解析\"><a href=\"#贰、-核心类解析\" class=\"headerlink\" title=\"贰、 核心类解析\"></a>贰、 核心类解析</h1><h2 id=\"2-1、ProcessorSlotChain\"><a href=\"#2-1、ProcessorSlotChain\" class=\"headerlink\" title=\"2.1、ProcessorSlotChain\"></a>2.1、ProcessorSlotChain</h2><p><code>Sentinel</code> 的核心骨架，将不同的 <code>Slot</code> 按照顺序串在一起（责任链模式），从而将不同的功能（限流、降级、系统保护）组合在一起。<code>slot chain</code> 其实可以分为两部分：统计数据构建部分（statistic）和判断部分（rule checking）。核心结构：</p>\n<p><img src=\"https://image.eelve.com/eblog/2021053001.png\" alt=\"总体框架图\"></p>\n<p>目前的设计是 <code>one slot chain per resource</code>，因为某些 <code>slot</code> 是 <code>per resource</code> 的（比如 <code>NodeSelectorSlot</code>）。</p>\n<h2 id=\"2-2、Context\"><a href=\"#2-2、Context\" class=\"headerlink\" title=\"2.2、Context\"></a>2.2、Context</h2><p><code>Context</code> 代表调用链路上下文，贯穿一次调用链路中的所有 <code>Entry</code>。<code>Context</code> 维持着入口节点（entranceNode）、本次调用链路的 <code>curNode</code>、调用来源（origin）等信息。<code>Context</code> 名称即为调用链路入口名称。</p>\n<p><code>Context</code> 维持的方式：通过 <code>ThreadLocal</code> 传递，只有在入口 <code>enter</code> 的时候生效。由于 <code>Context</code> 是通过 <code>ThreadLocal</code> 传递的，因此对于异步调用链路，线程切换的时候会丢掉 <code>Context</code>，因此需要手动通过 <code>ContextUtil.runOnContext(context, f)</code> 来变换 <code>context</code>。</p>\n<h2 id=\"2-3、Entry\"><a href=\"#2-3、Entry\" class=\"headerlink\" title=\"2.3、Entry\"></a>2.3、Entry</h2><p>每一次资源调用都会创建一个 <code>Entry</code>。<code>Entry</code> 包含了资源名、curNode（当前统计节点）、originNode（来源统计节点）等信息。</p>\n<p><code>CtEntry</code> 为普通的 <code>Entry</code>，在调用 <code>SphU.entry(xxx)</code> 的时候创建。特性：<code>Linked entry within current context（内部维护着 parent 和 child）</code></p>\n<p>需要注意的一点：<code>CtEntry</code> 构造函数中会做调用链的变换，即将当前 <code>Entry</code> 接到传入 <code>Context</code> 的调用链路上（setUpEntryFor）。</p>\n<p>资源调用结束时需要 <code>entry.exit()</code>。<code>exit</code> 操作会过一遍 <code>slot chain exit</code>，恢复调用栈，<code>exit context</code> 然后清空 <code>entry</code> 中的 <code>context</code> 防止重复调用。</p>\n<h2 id=\"2-4、Node\"><a href=\"#2-4、Node\" class=\"headerlink\" title=\"2.4、Node\"></a>2.4、Node</h2><p><code>Sentinel</code> 里面的各种种类的统计节点：</p>\n<ul>\n<li><code>StatisticNode</code>：最为基础的统计节点，包含秒级和分钟级两个滑动窗口结构。</li>\n<li><code>DefaultNode</code>：链路节点，用于统计调用链路上某个资源的数据，维持树状结构。</li>\n<li><code>ClusterNode</code>：簇点，用于统计每个资源全局的数据（不区分调用链路），以及存放该资源的按来源区分的调用数据（类型为 <code>StatisticNode</code>）。特别地，<code>Constants.ENTRY_NODE</code> 节点用于统计全局的入口资源数据。</li>\n<li><code>EntranceNode</code>：入口节点，特殊的链路节点，对应某个 <code>Context</code> 入口的所有调用数据。<code>Constants.ROOT</code> 节点也是入口节点。</li>\n</ul>\n<p>构建的时机：</p>\n<ul>\n<li><code>EntranceNode</code>：在 <code>ContextUtil.enter(xxx)</code> 的时候就创建了，然后塞到 <code>Context</code> 里面。</li>\n<li><code>NodeSelectorSlot</code>：根据 <code>context</code> 创建 <code>DefaultNode</code>，然后 <code>set curNode to context</code>。</li>\n<li><code>ClusterBuilderSlot</code>：首先根据 <code>resourceName</code> 创建 <code>ClusterNode</code>，并且 <code>set clusterNode to defaultNode</code>；然后再根据 <code>origin</code> 创建来源节点（类型为 <code>StatisticNode</code>），并且 <code>set originNode to curEntry</code>。</li>\n</ul>\n<p>几种 <code>Node</code> 的维度（数目）：</p>\n<ul>\n<li><code>ClusterNode</code> 的维度是 <code>resource</code></li>\n<li><code>DefaultNode</code> 的维度是 <code>resource * context</code>，存在每个 <code>NodeSelectorSlot</code> 的 <code>map</code> 里面</li>\n<li><code>EntranceNode</code> 的维度是 <code>context</code>，存在 <code>ContextUtil</code> 类的 <code>contextNameNodeMap</code> 里面</li>\n<li>来源节点（类型为 <code>StatisticNode</code>）的维度是 <code>resource * origin</code>，存在每个 <code>ClusterNode</code> 的 <code>originCountMap</code> 里面</li>\n</ul>\n<h2 id=\"2-5、StatisticSlot\"><a href=\"#2-5、StatisticSlot\" class=\"headerlink\" title=\"2.5、StatisticSlot\"></a>2.5、StatisticSlot</h2><p><code>StatisticSlot</code> 是 <code>Sentinel</code> 最为重要的类之一，用于根据规则判断结果进行相应的统计操作。</p>\n<p><code>entry</code> 的时候：依次执行后面的判断 <code>slot</code>。每个 <code>slot</code> 触发流控的话会抛出异常（<code>BlockException</code> 的子类）。若有 BlockException 抛出，则记录 block 数据；若无异常抛出则算作可通过（pass），记录 pass 数据。</p>\n<p><code>exit</code> 的时候：若无 <code>error（无论是业务异常还是流控异常）</code>，记录 <code>complete（success）</code>以及 <code>RT</code>，线程数<code>-1</code>。</p>\n<p>记录数据的维度：线程数<code>+1</code>、记录当前 <code>DefaultNode</code> 数据、记录对应的 <code>originNode</code> 数据（若存在 <code>origin</code>）、累计 <code>IN</code> 统计数据（若流量类型为 <code>IN</code>）。</p>\n<hr>\n<p>【<strong>后面的话</strong>】<a href=\"https://github.com/eelve/awesomesentinel\">最后是我自己实践自定义调用链的源码</a> 。</p>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","raw":null,"categories":[{"name":"sentinel","path":"api/categories/sentinel.json"}],"tags":[{"name":"sentinel","path":"api/tags/sentinel.json"}]},{"title":"浅析限流算法","slug":"浅析限流算法","date":"2021-04-05T02:14:08.000Z","updated":"2021-04-19T06:44:39.252Z","comments":true,"path":"api/articles/浅析限流算法.json","excerpt":null,"keywords":"南国薏米","cover":"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png","content":"<p>【<strong>前情提要</strong>】</p>\n<h1 id=\"壹、\"><a href=\"#壹、\" class=\"headerlink\" title=\"壹、\"></a>壹、</h1><h1 id=\"贰、\"><a href=\"#贰、\" class=\"headerlink\" title=\"贰、\"></a>贰、</h1><hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","raw":null,"categories":[{"name":"hide","path":"api/categories/hide.json"}],"tags":[{"name":"hide","path":"api/tags/hide.json"}]},{"title":"基于Redis实现简单的限流","slug":"基于Redis实现简单的限流","date":"2021-04-03T14:58:13.000Z","updated":"2021-04-19T06:44:39.244Z","comments":true,"path":"api/articles/基于Redis实现简单的限流.json","excerpt":null,"keywords":"南国薏米","cover":"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png","content":"<p>【<strong>前情提要</strong>】前面说过目前几种比较常见的限流的中间件，Sentinel、Hystrix和resilience4j，也提到过自己实现限流功能，今天就基于Redis实现一哈限流功能。</p>\n<h1 id=\"壹、Redis实现限流介绍\"><a href=\"#壹、Redis实现限流介绍\" class=\"headerlink\" title=\"壹、Redis实现限流介绍\"></a>壹、Redis实现限流介绍</h1><p>前面说过基于Guava的限流的解决方案，但是这个方案只适用于单体应用，所以这边我们就可用借助第三方中间件来实现，这里就使用Redis来实现，进一步实现集群限流的功能。主要参考Redis官方的伪代码：<a href=\"https://redis.io/commands/incr\">https://redis.io/commands/incr</a></p>\n<h1 id=\"贰、基于Redis的setnx的操作\"><a href=\"#贰、基于Redis的setnx的操作\" class=\"headerlink\" title=\"贰、基于Redis的setnx的操作\"></a>贰、基于Redis的setnx的操作</h1><p>我们在使用Redis的分布式锁的时候，大家都知道是依靠了setnx的指令，在CAS（Compare and swap）的操作的时候，同时给指定的key设置了过期实践（expire），我们在限流的主要目的就是为了在单位时间内，有且仅有N数量的请求能够访问我的代码程序。所以依靠setnx可以很轻松的做到这方面的功能。</p>\n<p>比如我们需要在10秒内限定20个请求，那么我们在setnx的时候可以设置过期时间10，当请求的setnx数量达到20时候即达到了限流效果。代码比较简单就不做展示了。</p>\n<p>当然这种做法的弊端是很多的，比如当统计1-10秒的时候，无法统计2-11秒之内，如果需要统计N秒内的M个请求，那么我们的Redis中需要保持N个key等等问题。</p>\n<h1 id=\"叁、基于Redis的数据结构zset\"><a href=\"#叁、基于Redis的数据结构zset\" class=\"headerlink\" title=\"叁、基于Redis的数据结构zset\"></a>叁、基于Redis的数据结构zset</h1><p>其实限流涉及的最主要的就是滑动窗口，上面也提到1-10怎么变成2-11。其实也就是起始值和末端值都各+1即可。</p>\n<p>而我们如果用Redis的list数据结构可以轻而易举的实现该功能，我们可以将请求打造成一个zset数组，当每一次请求进来的时候，value保持唯一，可以用UUID生成，而score可以用当前时间戳表示，因为score我们可以用来计算当前时间戳之内有多少的请求数量。而zset数据结构也提供了range方法让我们可以很轻易的获取到2个时间戳内有多少请求</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">limitFlow</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Long currentTime = <span class=\"keyword\">new</span> Date().getTime();</span><br><span class=\"line\">    System.out.println(currentTime);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(redisTemplate.hasKey(<span class=\"string\">&quot;limit&quot;</span>)) &#123;</span><br><span class=\"line\">        Integer count = redisTemplate.opsForZSet().rangeByScore(<span class=\"string\">&quot;limit&quot;</span>, currentTime -  intervalTime, currentTime).size();        <span class=\"comment\">// intervalTime是限流的时间 </span></span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count != <span class=\"keyword\">null</span> &amp;&amp; count &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Response.ok(<span class=\"string\">&quot;每分钟最多只能访问5次&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    redisTemplate.opsForZSet().add(<span class=\"string\">&quot;limit&quot;</span>,UUID.randomUUID().toString(),currentTime);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Response.ok(<span class=\"string\">&quot;访问成功&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述代码可以做到滑动窗口的效果，并且能保证每N秒内至多M个请求，缺点就是zset的数据结构会越来越大。实现方式相对也是比较简单的。</p>\n<h1 id=\"肆、基于Redis的令牌桶算法\"><a href=\"#肆、基于Redis的令牌桶算法\" class=\"headerlink\" title=\"肆、基于Redis的令牌桶算法\"></a>肆、基于Redis的令牌桶算法</h1><p>令牌桶算法提及到输入速率和输出速率，当输出速率大于输入速率，那么就是超出流量限制了。也就是说我们每访问一次请求的时候，可以从Redis中获取一个令牌，如果拿到令牌了，那就说明没超出限制，而如果拿不到，则结果相反。</p>\n<p>依靠上述的思想，我们可以结合Redis的List数据结构很轻易的做到这样的代码，只是简单实现依靠List的leftPop来获取令牌</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出令牌</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">limitFlow2</span><span class=\"params\">(Long id)</span></span>&#123;</span><br><span class=\"line\">    Object result = redisTemplate.opsForList().leftPop(<span class=\"string\">&quot;limit_list&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Response.ok(<span class=\"string\">&quot;当前令牌桶中无令牌&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Response.ok(articleDescription2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再依靠Java的定时任务，定时往List中rightPush令牌，当然令牌也需要唯一性，所以我这里还是用UUID进行了生成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 10S的速率往令牌桶中添加UUID，只为保证唯一性</span></span><br><span class=\"line\"><span class=\"meta\">@Scheduled(fixedDelay = 10_000,initialDelay = 0)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIntervalTimeTask</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    redisTemplate.opsForList().rightPush(<span class=\"string\">&quot;limit_list&quot;</span>,UUID.randomUUID().toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","raw":null,"categories":[{"name":"limiting","path":"api/categories/limiting.json"}],"tags":[{"name":"limiting","path":"api/tags/limiting.json"}]},{"title":"基于Guava实现限流","slug":"基于Guava实现限流","date":"2021-04-03T14:06:18.000Z","updated":"2021-04-19T06:44:39.227Z","comments":true,"path":"api/articles/基于Guava实现限流.json","excerpt":null,"keywords":"南国薏米","cover":"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png","content":"<p>【<strong>前情提要</strong>】前面说过目前几种比较常见的限流的中间件，Sentinel、Hystrix和resilience4j，也提到过自己实现限流功能，今天就基于Guava实现一哈限流功能。</p>\n<h1 id=\"壹、Guava介绍\"><a href=\"#壹、Guava介绍\" class=\"headerlink\" title=\"壹、Guava介绍\"></a>壹、Guava介绍</h1><p><a href=\"https://github.com/google/guava\">Guava</a> 是一种基于开源的Java库，其中包含谷歌正在由他们很多项目使用的很多核心库。这个库是为了方便编码，并减少编码错误。这个库提供用于集合，缓存，支持原语，并发性，常见注解，字符串处理，I/O和验证的实用方法。</p>\n<p><a href=\"https://github.com/google/guava\">Guava</a> 的好处</p>\n<ul>\n<li>标准化 - Guava库是由谷歌托管。 </li>\n<li>高效 - 可靠，快速和有效的扩展JAVA标准库</li>\n<li>优化 -Guava库经过高度的优化。</li>\n<li>函数式编程 -增加JAVA功能和处理能力。</li>\n<li>实用程序 - 提供了经常需要在应用程序开发的许多实用程序类。</li>\n<li>验证 -提供标准的故障安全验证机制。</li>\n<li>最佳实践 - 强调最佳的做法。</li>\n</ul>\n<p>下面就使用<a href=\"https://github.com/google/guava\">Guava</a> 中提供的并发相关的工具中的<code>RateLimiter</code>来实现一个限流的功能。</p>\n<h1 id=\"贰、引入依赖\"><a href=\"#贰、引入依赖\" class=\"headerlink\" title=\"贰、引入依赖\"></a>贰、引入依赖</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;30.0-jre&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"叁、拦截器方式实现\"><a href=\"#叁、拦截器方式实现\" class=\"headerlink\" title=\"叁、拦截器方式实现\"></a>叁、拦截器方式实现</h1><h2 id=\"3-1、-定义接口\"><a href=\"#3-1、-定义接口\" class=\"headerlink\" title=\"3.1、 定义接口\"></a>3.1、 定义接口</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/get&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JsonResult <span class=\"title\">allInfos</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, <span class=\"meta\">@RequestParam</span> Integer num)</span></span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;param-----&gt;&quot;</span> + num);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(num*<span class=\"number\">100</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num % <span class=\"number\">3</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;num % 3 == 0&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BaseException(<span class=\"string\">&quot;something bad whitch 3&quot;</span>, <span class=\"number\">400</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num % <span class=\"number\">5</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;num % 5 == 0&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProgramException(<span class=\"string\">&quot;something bad whitch 5&quot;</span>, <span class=\"number\">400</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num % <span class=\"number\">7</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;num % 7 == 0&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> res = <span class=\"number\">1</span> / <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> JsonResult.ok();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ProgramException | InterruptedException exception) &#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> JsonResult.error(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2、-添加拦截器\"><a href=\"#3-2、-添加拦截器\" class=\"headerlink\" title=\"3.2、 添加拦截器\"></a>3.2、 添加拦截器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.eelve.limiting.guava.aspect;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.eelve.limiting.guava.vo.JsonResult;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.http.MediaType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.StandardCharsets;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> RateLimiterInterceptor</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span> TODO</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> zhao.zhilue</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span> 2021/1/11 12:10</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RateLimiterInterceptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RateLimiter rateLimiter;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过构造函数初始化限速器</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RateLimiterInterceptor</span><span class=\"params\">(RateLimiter rateLimiter)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.rateLimiter = rateLimiter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.rateLimiter.tryAcquire()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 成功获取到令牌</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 获取失败，直接响应“错误信息”</span></span><br><span class=\"line\"><span class=\"comment\">         * 也可以通过抛出异常，通过全全局异常处理器响应客户端</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        response.setCharacterEncoding(StandardCharsets.UTF_8.name());</span><br><span class=\"line\">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class=\"line\">        response.getWriter().write(JsonResult.error().toString());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.eelve.limiting.guava.configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.eelve.limiting.guava.aspect.RateLimiterInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> WebMvcConfiguration</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span> TODO</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> zhao.zhilue</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span> 2021/1/11 12:14</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfiguration</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebMvcConfigurer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * get接口，1秒钟生成1个令牌，也就是1秒中允许一个人访问</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> RateLimiterInterceptor(RateLimiter.create(<span class=\"number\">1</span>, <span class=\"number\">1</span>, TimeUnit.SECONDS)))</span><br><span class=\"line\">                .addPathPatterns(<span class=\"string\">&quot;/get&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>通过上面的代码我们就可用对<code>/get</code>接口实现限流了，但是也有明显的缺点，就是规则被写死，所以下面我们通过注解方式实现。</p>\n</blockquote>\n<h1 id=\"肆、使用注解实现\"><a href=\"#肆、使用注解实现\" class=\"headerlink\" title=\"肆、使用注解实现\"></a>肆、使用注解实现</h1><h2 id=\"4-1、定义注解\"><a href=\"#4-1、定义注解\" class=\"headerlink\" title=\"4.1、定义注解\"></a>4.1、定义注解</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.eelve.limiting.guava.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhao.zhilue</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/1/1112:27</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MyRateLimiter &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> NOT_LIMITED = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 资源名称</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * qps</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">qps</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> NOT_LIMITED</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取令牌超时时长</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 超时时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">TimeUnit <span class=\"title\">timeUnit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.MILLISECONDS</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 执行超时时长</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">executeTimeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 执行超时时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">TimeUnit <span class=\"title\">executeTimeUnit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.MILLISECONDS</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2、添加通知\"><a href=\"#4-2、添加通知\" class=\"headerlink\" title=\"4.2、添加通知\"></a>4.2、添加通知</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.eelve.limiting.guava.aspect;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.eelve.limiting.guava.annotation.MyRateLimiter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.eelve.limiting.guava.exception.BaseException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Around;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.annotation.AnnotationUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Objects;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> RateLimiterAspect</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span> TODO</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> zhao.zhilue</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span> 2021/1/11 12:28</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRateLimiterAspect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, RateLimiter&gt; RATE_LIMITER_CACHE = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(com.eelve.limiting.guava.annotation.MyRateLimiter)&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">MyRateLimit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;MyRateLimit()&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">pointcut</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        Object obj =<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        MethodSignature signature = (MethodSignature) point.getSignature();</span><br><span class=\"line\">        Method method = signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">// 通过 AnnotationUtils.findAnnotation 获取 RateLimiter 注解</span></span><br><span class=\"line\">        MyRateLimiter myRateLimiter = AnnotationUtils.findAnnotation(method, MyRateLimiter.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (myRateLimiter != <span class=\"keyword\">null</span> &amp;&amp; myRateLimiter.qps() &gt; MyRateLimiter.NOT_LIMITED) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">double</span> qps = myRateLimiter.qps();</span><br><span class=\"line\">            String name = myRateLimiter.name();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> executeTimeout = myRateLimiter.executeTimeout();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Objects.isNull(name))&#123;</span><br><span class=\"line\">                name = method.getName();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (RATE_LIMITER_CACHE.get(name) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 初始化 QPS</span></span><br><span class=\"line\">                RATE_LIMITER_CACHE.put(name, RateLimiter.create(qps));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;【&#123;&#125;】的QPS设置为: &#123;&#125;&quot;</span>, method.getName(), RATE_LIMITER_CACHE.get(name).getRate());</span><br><span class=\"line\">            Long start = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"comment\">// 尝试获取令牌</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (RATE_LIMITER_CACHE.get(method.getName()) != <span class=\"keyword\">null</span> &amp;&amp; !RATE_LIMITER_CACHE.get(method.getName()).tryAcquire(myRateLimiter.timeout(), myRateLimiter.timeUnit())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BaseException(<span class=\"string\">&quot;请求频繁，请稍后再试~&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            obj = point.proceed();</span><br><span class=\"line\"></span><br><span class=\"line\">            Long end = System.currentTimeMillis();</span><br><span class=\"line\">            Long executeTime = end - start;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((end - start) &gt;  executeTimeout)&#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;请求超时，请稍后再试~&quot;</span> + (end - start));</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BaseException(<span class=\"string\">&quot;请求超时，请稍后再试~&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-3、使用\"><a href=\"#4-3、使用\" class=\"headerlink\" title=\"4.3、使用\"></a>4.3、使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 开启限流</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@MyRateLimiter(qps = 2.0, timeout = 1)</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/rateLimiter&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JsonResult <span class=\"title\">rateLimiter</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, <span class=\"meta\">@RequestParam</span> Integer num)</span> </span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;param-----&gt;&quot;</span> + num);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(num);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;【rateLimiter】被执行了。。。。。&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> JsonResult.ok(<span class=\"string\">&quot;你不能总是看到我，快速刷新我看一下！&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>通过上面的代码我们就实现了零活的通过注解的方式实现了限流功能，并且我们还可以在<code>Around</code>通知的时候灵活实现。包括过滤某些异常等等。</p>\n</blockquote>\n<hr>\n<p>【<strong>后面的话</strong>】除了前面我们使用的<code>RateLimiter</code>之外，<code>Guava</code>还提供了专门针对超时的<code>SimpleTimeLimiter</code>组件，有兴趣的也可以尝试一下。另外以上的源码都可用在 <a href=\"https://github.com/eelve/limiting/tree/master/guava\">limiting</a> 中找到。</p>\n<p><img src=\"https://image.eelve.com/eblog/eblog-b269767ff45b4e01a1c380e38898c1c0.png\" alt=\"薏米笔记\"></p>\n","raw":null,"categories":[{"name":"limiting","path":"api/categories/limiting.json"}],"tags":[{"name":"limiting","path":"api/tags/limiting.json"}]}]}